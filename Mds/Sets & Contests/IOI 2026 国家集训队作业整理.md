## é¢˜ç›®æ•´ç†

### 1. Cells Blocking

é¦–å…ˆå¦‚æœ $(1,1)$ å’Œ $(n,m)$ ä¸è¿é€šï¼Œé‚£ä¹ˆæ–¹æ¡ˆæ•°å°±æ˜¯ $\dbinom c2$ï¼Œå…¶ä¸­ $c$ æ˜¯ç©ºåœ°ä¸ªæ•°ã€‚

å¦‚æœ $(1,1)$ å’Œ $(n,m)$ æœ¬å°±è”é€šï¼Œé‚£ä¹ˆä¸¤ä¸ªé€‰å–çš„ç‚¹å¿…ç„¶è‡³å°‘æœ‰ä¸€ä¸ªåœ¨æœ€å·¦ä¸‹è·¯å¾„ä¸Šã€‚è€ƒè™‘æšä¸¾è¿™ä¸ªç‚¹ï¼Œè®¾ä¸º $(x,y)$ï¼Œé‚£ä¹ˆå¦ä¸€ä¸ªç‚¹å°±æ˜¯æ–°å›¾ä¸­ $(1,1)$ åˆ° $(n,m)$ çš„å¿…ç»ç‚¹ï¼Œè€Œä» $(1,1)$ åˆ° $(n,m)$ å¿…ç»çš„ç‚¹ä¸€å®šæ˜¯æœ€å·¦ä¸‹çš„è·¯å¾„å’Œæœ€å³ä¸Šçš„è·¯å¾„çš„äº¤ç‚¹ã€‚å‡è®¾å›¾ä»è”é€šï¼Œé‚£ä¹ˆæœ€å³ä¸Šè·¯å¾„ä¸å˜ï¼Œè€ƒè™‘å¦‚ä½•æ‰¾åˆ°æ–°çš„æœ€å·¦ä¸‹è·¯å¾„ã€‚ç”±äºæ¯æ¡è·¯å¾„ $x+y=c$ ä¸Šåªä¼šæ°å¥½é€‰ä¸€ä¸ªç‚¹ï¼Œå› æ­¤æ‰¾åˆ°æœ€å°çš„ $k$ ä½¿å¾— $(x-k,y+k)$ ä»èƒ½åˆ°è¾¾ $(1,1)$ å’Œ $(n,m)$ï¼Œæ‰¾å‡ºå…¶åˆ° $(1,1)$ å’Œ $(n,m)$ çš„æœ€å·¦ä¸‹è·¯å¾„å¹¶æ‹¼æ¥èµ·æ¥å°±æ˜¯æ–°çš„æœ€å·¦ä¸‹è·¯å¾„ã€‚å’Œæœ€å³ä¸Šè·¯å¾„å½’å¹¶å³å¯æ‰¾å‡ºæ‰€æœ‰äº¤ç‚¹ã€‚æ—¶é—´å¤æ‚åº¦ $O((n+m)^2)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e3+9;

int ban[N][N],n,m;
char a[N][N],lu[N][N],rd[N][N];
inline bool Valid(char c[N][N],int i,int j){return c[i][j]!='*'&&c[i][j];}
template<class T> inline int Merge(vector<T> u,vector<T> v){
	int cnt=0;
	while(u.size()){
		while(v.size()&&v.back()>u.back()) v.pop_back();
		if(v.size()&&v.back()==u.back()) cnt+=!ban[v.back()[0]][v.back()[1]];
		u.pop_back();
	}
	return cnt;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>a[i][j];
	}

	int cnt=0;
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++) cnt+=(a[i][j]=='.');
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			if(a[i][j]=='*') lu[i][j]='*';
			else if(i==1&&j==1) lu[i][j]='.';
			else if(Valid(lu,i,j-1)||Valid(lu,i-1,j)) lu[i][j]='~';
			else lu[i][j]='*';
		}
	}
	for(int i=n;i>=1;i--){
		for(int j=m;j>=1;j--){
			if(a[i][j]=='*') ;
			else if(i==n&&j==m) rd[i][j]='.';
			else if(Valid(rd,i,j+1)||Valid(rd,i+1,j)) rd[i][j]='~';
			else rd[i][j]='*';
		}
	}

	if(!Valid(rd,1,1)){
		cout<<1ll*cnt*(cnt-1)/2<<endl;
		return 0;
	}

	vector<array<int,2>> rp;
	for(int i=1,j=1;;){
		rp.push_back({i,j});
		if(rd[i][j]=='.') break ;
		else if(Valid(rd,i,j+1)) j++;
		else if(Valid(rd,i+1,j)) i++;
	}

	ll ans=0,c=0;
	for(int i=1,j=1;;){
		int k=1;
		while(i-k>=1&&j+k<=m&&(!Valid(lu,i-k,j+k)||!Valid(rd,i-k,j+k))) k++;
		if(i-k<1||j+k>m) ans+=cnt-c-1;
		else{
			vector<array<int,2>> lp;
			for(int p=i-k,q=j+k;;){
				lp.push_back({p,q});
				if(lu[p][q]=='.') break ;
				else if(Valid(lu,p,q-1)) q--;
				else if(Valid(lu,p-1,q)) p--;
			}
			reverse(lp.begin(),lp.end());
			lp.pop_back();
			for(int p=i-k,q=j+k;;){
				lp.push_back({p,q});
				if(rd[p][q]=='.') break ;
				else if(Valid(rd,p+1,q)) p++;
				else if(Valid(rd,p,q+1)) q++;
			}
			ans+=Merge(lp,rp);
		}
		c++;
		ban[i][j]=1;
		if(rd[i][j]=='.') break ;
		else if(Valid(rd,i+1,j)) i++;
		else if(Valid(rd,i,j+1)) j++;
	}
	
	cout<<ans<<endl;

	return 0;
}
```

### 2. Giant Penguin

è€ƒè™‘å»ºå‡ºç‚¹åˆ†æ ‘ï¼Œé‚£ä¹ˆä¸€æ¡è·¯å¾„è¦ä¹ˆè·¨è¿‡åˆ†æ²»ä¸­å¿ƒï¼Œè¦ä¹ˆè·¨è¿‡ä¸€ä¸ªè·¨è¿‡åˆ†æ²»ä¸­å¿ƒçš„æ¨ªå‰è¾¹ã€‚ç”±äºè¿™ç§æ¨ªå‰è¾¹å¯ä»¥å’Œåˆ†æ”¯ä¸­å¿ƒæ„æˆä¸€ä¸ªç®€å•ç¯ï¼Œå› æ­¤è¿™ç§è¾¹ä¸ä¼šè¶…è¿‡ $k$ æ¡ã€‚è€ƒè™‘ç”¨ BFS é¢„å¤„ç†å­æ ‘å†…å„ä¸ªèŠ‚ç‚¹åˆ°åˆ†æ²»ä¸­å¿ƒä»¥åŠå„ä¸ªæ¨ªå‰è¾¹ä¹‹é—´çš„è·ç¦»ï¼Œé‚£ä¹ˆå‰©ä¸‹çš„ä¿¡æ¯åˆ™å¯ä»¥åŠ¨æ€ç»´æŠ¤ï¼Œæ—¶é—´å¤æ‚åº¦ $O((n+q)k\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e5+9;
const int K=1e1+9;
const int lgN=2e1;

int typ[N],n,m,k,q;
vector<array<int,2>> e[N];

int vis[N];
inline void GetTE(int x){
	vis[x]=1;
	for(auto p:e[x]){
		if(!vis[p[0]]){
			typ[p[1]]=1;
			GetTE(p[0]);
		}
	}
}
int mrk[N],siz[N];
inline void GetGrv(int x,int fa,int tot,int &grv){
	bool err=0;
	siz[x]=1;
	for(auto p:e[x]){
		if(p[0]==fa) continue ;
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		GetGrv(p[0],x,tot,grv);
		siz[x]+=siz[p[0]];
		err|=(siz[p[0]]>tot/2);
	}
	err|=(tot-siz[x]>tot/2);
	if(!err) grv=x;
}
int col[N],cp[N];
inline void Color(int x,int fa,int c,int rt,vector<int> &v){
	col[x]=c,cp[x]=rt;
	v.push_back(x);
	for(auto p:e[x]){
		if(p[0]==fa) continue ;
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		Color(p[0],x,c,rt,v);
	}
}
int dep[lgN][K][N],mn[N][K];
inline void BFS(int s,int *dep){
	dep[s]=0;
	queue<int> q;
	q.push(s);
	while(q.size()){
		int x=q.front();
		q.pop();
		for(auto p:e[x]){
			if(mrk[p[0]]) continue ;
			if(!~typ[p[1]]) continue ;
			if(dep[x]+1<dep[p[0]]){
				dep[p[0]]=dep[x]+1;
				q.push(p[0]);
			}
		}
	}
}
int d[N],up[N],ec[N];
inline void Conquer(int x,int tot,int u){
	GetGrv(x,-1,tot,x);
	GetGrv(x,-1,tot,x);
	up[x]=u,d[x]=d[u]+1;

	int ccnt=0;
	vector<int> sv;
	col[x]=0,cp[x]=x;
	for(auto p:e[x]){
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		Color(p[0],x,++ccnt,x,sv);
	}
	for(int y:sv){
		for(auto p:e[y]){
			if(mrk[p[0]]) continue ;
			if(typ[p[1]]) continue ;
			if(cp[p[0]]!=x) continue ;
			if(col[p[0]]<=col[y]) continue ;
			BFS(y,dep[d[x]][++ec[x]]);
			typ[p[1]]=-1;
		}
	}
	BFS(x,dep[d[x]][++ec[x]]);

	mrk[x]=1;

	for(auto p:e[x]){
		if(mrk[p[0]]) continue ;
		if(typ[p[1]]!=1) continue ;
		Conquer(p[0],siz[p[0]],x);
	}
}

inline void Update(int x){
	for(int y=x;y;y=up[y]){
		for(int i=1;i<=ec[y];i++) mn[y][i]=min(mn[y][i],dep[d[y]][i][x]);
	}
}
inline int Calc(int x){
	int ans=1e9;
	for(int y=x;y;y=up[y]){
		for(int i=1;i<=ec[y];i++) ans=min(ans,mn[y][i]+dep[d[y]][i][x]);
	}
	return ans;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m>>k;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		e[u].push_back({v,i});
		e[v].push_back({u,i});
	}

	memset(mn,0x3f,sizeof mn);
	memset(dep,0x3f,sizeof dep);
	GetTE(1);
	Conquer(1,n,0);

	cin>>q;
	while(q--){
		int op,x;
		cin>>op>>x;
		if(op==1) Update(x);
		else cout<<Calc(x)<<endl;
	}

	return 0;
}
```

### 3. Edit Distance Yet Again

é¦–å…ˆæŠŠ $O(n^2)$ çš„ DP è¿‡ç¨‹æ”¾åˆ°å¹³é¢ä¸Šè€ƒè™‘ï¼Œé‚£ä¹ˆç­”æ¡ˆå°±å˜æˆäº† $S=(1,1)$ åˆ° $T=(n+1,m+1)$ çš„æœ€çŸ­è·¯ã€‚

æœ‰ä¸€ä¸ªå…³é”®æ€§è´¨æ˜¯ï¼Œå¯¹äº $d(S\rightarrow(i,i+\Delta))=d(S\rightarrow(j,j+\Delta))$ çš„ $i<j$ å’Œ $\Delta$ï¼Œä» $(i,i+\Delta)$ è½¬ç§»ä¸€å®šä¸ä¼˜ã€‚

è¯æ˜è€ƒè™‘ $(i,i+\Delta)$ è·¯å¾„ä¸Šçš„ç‚¹ $(j,k)$ï¼Œå…¶ä¸­ $k\geq j+\Delta$ï¼Œé‚£ä¹ˆ $d((j,j+\Delta)\rightarrow(j,k))\leq d((i,i+\Delta)\rightarrow(j,k))$ï¼Œæ‰€ä»¥ $(j,j+\Delta)$ æ›´ä¼˜ã€‚å¦‚æœä¸å­˜åœ¨ $(j,k)$ åˆ™å¯ä»¥ç”¨ $(k,j+\Delta)$ ç±»ä¼¼åœ°è¯æ˜ï¼Œå› ä¸º $(j,k)$ å’Œ $(k,j+\Delta)$ ä¸€å®šè‡³å°‘å­˜åœ¨ä¸€ä¸ªã€‚

å°†æ‰€æœ‰è¿™æ ·çš„ç‚¹ç¼©åœ¨ä¸€èµ·ä¹‹åï¼Œæœ‰æ•ˆçŠ¶æ€æ•°å°±æ˜¯ $O(k^2)$ çš„ï¼ŒåŸç†æ˜¯ $0 \leq d(S\rightarrow (i,i+\Delta)) \leq k$ï¼Œè€Œ $-k \leq \Delta \leq k$ã€‚æ‰¾åˆ°ä¸€ç»„ $(d,\Delta)$ æœ€æœ‰ç”¨çš„ $i$ å¯ä»¥ç›´æ¥æŸ¥è¯¢åç¼€çš„ LCPï¼Œä¸€å±‚ä¸€å±‚åœ°è½¬ç§»å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O((n+k^2) \log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
using ull=unsigned long long;
using bint=__int128;
const int N=2e6+9;
const int K=1e3+9;
const int lgN=2e1;
const ll mod=114514191981000001ll;
const ll base=1000;

inline void AddAs(ll &x,ll y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(ll &x,ll y){if((x-=y)<0) x+=mod;}
inline void MulAs(ll &x,ll y){x=bint(x)*y%mod;}
inline ll Add(ll x,ll y){if((x+=y)>=mod) x-=mod;return x;}
inline ll Sub(ll x,ll y){if((x-=y)<0) x+=mod;return x;}
inline ll Mul(ll x,ll y){return bint(x)*y%mod;}
inline ll QPow(ll x,ll y){
	ll res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline ll Inv(ll x){return QPow(x,mod-2);}

int n,m,k;
char s[N],t[N];
ll hs[N],ht[N],b[N],ib[N];
inline void Init(int lim){
	const ll ibase=Inv(base);
	ib[0]=b[0]=1;
	for(int i=1;i<=lim;i++){
		b[i]=Mul(b[i-1],base);
		ib[i]=Mul(ib[i-1],ibase);
	}
}
inline void CalcHash(char *s,ll *h,int n){
	for(int i=1;i<=n;i++) h[i]=Add(h[i-1],Mul(s[i],b[i-1]));
}
inline ll H(ll *h,int l,int r){return Mul(Sub(h[r],h[l-1]),ib[l-1]);}
inline int LCP(int i,int j){
	int l=0,r=min(n-i+1,m-j+1)+1;
	while(l+1<r){
		int mid=l+r>>1;
		if(H(hs,i,i+mid-1)==H(ht,j,j+mid-1)) l=mid;
		else r=mid;
	}
	return l;
}

int cnt=0;
const int dx[3]={1,0,1};
const int dy[3]={0,1,1};
int id[K][K<<1],pre[K][K<<1];
inline ull F(unsigned x,unsigned y){return (ull(x)<<23)^(ull(x)<<13)^(ull(x)<<3)^y;}
inline ull F(array<int,2> x){return F(x[0],x[1]);}
inline void Solve(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>s[i];
	for(int i=1;i<=m;i++) cin>>t[i];

	Init(max(n,m));
	CalcHash(s,hs,n);
	CalcHash(t,ht,m);
	
	auto T=[](array<int,2> p)->array<int,2>{
		int k=LCP(p[0],p[1]);
		return {p[0]+k,p[1]+k};
	};
	for(int i=0;i<=k;i++){
		for(int j=-k;j<=k;j++) id[i][K+j]=pre[i][K+j]=-1;
	}
	int p=-1;
	id[0][K+0]=1+LCP(1,1);
	for(int r=0;r<=k;r++){
		for(int d=-k;d<=k;d++){
			int i=id[r][K+d],j=i-d;
			if(!~i) continue ;
			if(i==n+1&&j==m+1){
				p=r;
				break ;
			}
			for(int o:{0,1,2}){
				if(i+dx[o]>n+1||j+dy[o]>m+1) continue ;
				array<int,2> nxt=T({i+dx[o],j+dy[o]});
				int u=nxt[0],v=nxt[1];
				if(u>id[r+1][K+u-v]){
					id[r+1][K+u-v]=u;
					pre[r+1][K+u-v]=i-j;
				}
			}
		}
		if(~p) break ;
	}

	if(~p){
		cout<<"YES"<<endl;
		cout<<p<<endl;
		vector<tuple<string,int,char>> ans;
		for(int r=p,i=n+1,j=m+1;r>=1;r--){
			int u=id[r-1][K+pre[r][K+i-j]],v=u-pre[r][K+i-j];
			if(!~u) break ;
			int dlt=(i-u)-(j-v);
			if(dlt==0) ans.push_back({"REPLACE",v,t[v]});
			else if(dlt==1) ans.push_back({"DELETE",v,'#'});
			else ans.push_back({"INSERT",v,t[v]});
			i=u,j=v;
		}
		reverse(ans.begin(),ans.end());
		for(auto t:ans){
			if(get<0>(t)=="DELETE") cout<<get<0>(t)<<' '<<get<1>(t)<<endl;
			else cout<<get<0>(t)<<' '<<get<1>(t)<<' '<<get<2>(t)<<endl;
		}
	}else cout<<"NO"<<endl;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 4. Cactus

ğŸŒµğŸŒµï¼Ÿï¼

é¦–å…ˆåªæœ‰ä¸€ä¸ªç¯æ˜¯ç»å…¸ DP é—®é¢˜ã€‚

å‘ç°æŠŠä»™äººæŒç¼©æˆæ ‘ä¹‹åç›¸å½“äºå¯¹éæ ¹çš„ç¯ä¸Šæœ€é«˜ç‚¹ ban æ‰ä¸€ç§é¢œè‰²ï¼Œå³ä»£ä»·ä¹˜ä¸Š $\dfrac {k}{k-1}$ã€‚

ç„¶ååˆèµ·æ¥å°±ğŸŒµå®Œäº†ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=4e5+9;
const int mod=1e9+7;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

vector<int> e[N],stk;
int dfn[N],low[N],ins[N],bel[N],len[N],f[N][2],g[N],n,m,k,dcnt,scnt;
inline void Tarjan(int x,int fa){
	ins[x]=1;
	stk.push_back(x);
	dfn[x]=low[x]=++dcnt;
	for(int y:e[x]){
		if(y==fa) continue ;
		if(!dfn[y]){
			Tarjan(y,x);
			low[x]=min(low[x],low[y]);
		}else if(ins[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		scnt++;
		while(stk.size()){
			int p=stk.back();
			stk.pop_back();
			bel[p]=scnt;
			len[scnt]++;
			ins[p]=0;
			if(p==x) break ;
		}
	}
}
inline void Solve(){
	cin>>n>>m>>k;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}
	
	Tarjan(1,0);

	f[1][0]=0,f[1][1]=1;
	for(int i=2;i<=n;i++){
		f[i][0]=Add(Mul(f[i-1][0],k-2),Mul(f[i-1][1],k-1));
		f[i][1]=f[i-1][0];
	}
	for(int i=1;i<=n;i++) g[i]=f[i][i==1];

	int ans=1;
	for(int i=1;i<=scnt;i++) MulAs(ans,Mul(k-1,g[len[i]]));
	MulAs(ans,Mul(k,Inv(k-1)));

	cout<<ans<<endl;

	dcnt=scnt=0;
	for(int i=1;i<=n;i++){
		e[i].clear();
		dfn[i]=low[i]=ins[i]=bel[i]=len[i]=0;
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 6. Social Justice

å¹³å‡å€¼å‡ ä¹æ²¡æœ‰ä»»ä½•æ€§è´¨ã€‚

é¦–å…ˆæ’å®ŒåºäºŒåˆ†ä¸€ä¸‹å°±å¯ä»¥æ‰¾å‡ºæœ€å¤šå‰©å‡ ä¸ªäººï¼Œç„¶åå¯¹äºæŸä¸ªæœ€å¤§å€¼ï¼Œå¯ä»¥ä½œä¸ºæœ€å°å€¼çš„ä½ç½®æ˜¯ä¸€ä¸ªåŒºé—´ï¼Œæ‰¾å‡ºæ¥æ±‚å¹¶å†åé€‰å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e5+9;
using ll=long long;

int p[N],c[N],d[N],n;
ll a[N],b[N],s[N],fp,fq;

inline void Solve(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	cin>>fp>>fq;

	iota(p+1,p+n+1,1);
	sort(p+1,p+n+1,[](int i,int j){return a[i]<a[j];});
	for(int i=1;i<=n;i++) s[i]=s[i-1]+(b[i]=a[p[i]]);
	for(int i=1;i<=n;i++){
		auto Check=[&](int p){return fp*(s[i]-s[p-1])>=b[i]*(i-p+1)*fq;};
		int l=0,r=i;
		while(l+1<r){
			int mid=l+r>>1;
			if(Check(mid)) r=mid;
			else l=mid;
		}
		c[i]=i-r+1;
	}
	
	int t=*max_element(c+1,c+n+1);
	for(int i=1,j=1;i<=n;i++){
		if(c[i]==t){
			auto Check=[&](int p){return fp*(s[i]-s[i-t+1]+b[p])>=b[i]*t*fq;};
			int l=0,r=i-t+1;
			while(l+1<r){
				int mid=l+r>>1;
				if(Check(mid)) r=mid;
				else l=mid;
			}
			d[r]++,d[i+1]--;
		}
	}

	vector<int> ans;
	for(int i=1;i<=n;i++) if(!(d[i]+=d[i-1])) ans.push_back(p[i]);
	sort(ans.begin(),ans.end());

	cout<<ans.size()<<endl;
	for(int x:ans) cout<<x<<' ';cout<<endl;

	for(int i=1;i<=n+1;i++) d[i]=0;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 8. Travel around China

ç”±äº $(*,l)\rightarrow (*,r)$ ä¸€å®šç»è¿‡ $l\leq p\leq r$ çš„ $p$ï¼Œè€ƒè™‘åˆ†æ²»ã€‚

ä»åˆ†æ²»ä¸­å¿ƒ $p$ å‡ºå‘ï¼Œè®¡ç®— $(o,p)$ åˆ° $[l,r]$ å†…æ‰€æœ‰ç‚¹çš„æœ€çŸ­è·¯ $d_o(i,j)$ã€‚é‚£ä¹ˆ $\displaystyle \min_{o=1}^n dis_o(i_1,j_1)+dis_o(i_2,j_2)$ å³ä¸º $(i_1,j_1)$ åˆ° $(i_2,j_2)$ çš„æœ€çŸ­è·¯ã€‚è¿™ä¸ªä¸œè¥¿çš„å’Œæ˜¯ç»å…¸é—®é¢˜ï¼Œå¯ä»¥äºŒç»´ååºè§£å†³ã€‚

æœ€çŸ­è·¯éƒ¨åˆ†å¯ä»¥ç›´æ¥ DIjkstraï¼Œæ³¨æ„ $l$ å¤„å¯ä»¥ä» $(1,l)$ ç»•å‡ºå»å†ä» $(3,l)$ ç»•å›æ¥ï¼Œéœ€è¦ç‰¹åˆ¤ï¼Œ$r$ å¤„åŒç†ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n^2m\log^2 m)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int M=2e5+9;
const ll inf=1e18;
const int mod=1e9+7;

ll d[3][3][M],ans;
int a[3][M],vis[3][M],n,m;
const int dx[4]={-1,0,1,0};
const int dy[4]={0,-1,0,1};
inline void Dij(int si,int sj,int l,int r,ll ld,ll rd,ll dis[3][M]){
	for(int i:{0,1,2}) for(int j=l;j<=r;j++) dis[i][j]=inf,vis[i][j]=0;
	dis[si][sj]=a[si][sj];
	priority_queue<array<ll,3>> q;
	q.push({-dis[si][sj],si,sj});
	while(q.size()){
		int i=q.top()[1],j=q.top()[2];
		q.pop();
		if(vis[i][j]) continue ;
		vis[i][j]=1;
		if(j==l&&(~i&1)){
			int k=i^2;
			if(dis[i][j]+a[k][j]+ld<dis[k][j]){
				dis[k][j]=dis[i][j]+a[k][j]+ld;
				q.push({-dis[k][j],k,j});
			}
		}
		if(j==r&&(~i&1)){
			int k=i^2;
			if(dis[i][j]+a[k][j]+rd<dis[k][j]){
				dis[k][j]=dis[i][j]+a[k][j]+rd;
				q.push({-dis[k][j],k,j});
			}
		}
		for(int o:{0,1,2,3}){
			int ii=i+dx[o],jj=j+dy[o];
			if(ii<0||jj<l||ii>2||jj>r) continue ;
			if(dis[i][j]+a[ii][jj]<dis[ii][jj]){
				dis[ii][jj]=dis[i][j]+a[ii][jj];
				q.push({-dis[ii][jj],ii,jj});
			}
		}
	}
}

struct Fenw{
	int lim;
	ll tr[M<<2];
	inline void Add(int x,ll k){while(x<=lim) tr[x]+=k,x+=x&-x;}
	inline ll Ask(int x){ll sum=0;while(x) sum+=tr[x],x&=x-1;return sum;}
	inline ll Ask(int l,int r){return Ask(r)-Ask(l-1);}
	inline void Clear(){while(lim) tr[lim--]=0;}
}C,S;

inline void Conquer(int l,int r,ll ld,ll rd){
	if(l>r) return ;
	int mid=l+r>>1;
	for(int i:{0,1,2}){
		Dij(i,mid,l,r,ld,rd,d[i]);
		for(int j:{0,1,2}){
			for(int k=l;k<=r;k++){
				if(k!=mid||i<j) ans=(ans+d[i][j][k])%mod;
			}
		}
	}
	for(int i:{0,1,2}) for(int j:{0,1,2}) for(int k=r;k>mid;k--) d[i][j][k]-=a[i][mid];
	for(int i:{0,1,2}){
		int x=(i+1)%3,y=(i+2)%3;
		vector<ll> val;
		vector<array<ll,3>> lv,rv;
		for(int j:{0,1,2}){
			for(int k=l;k<mid;k++){
				lv.push_back({(d[i][j][k]-d[x][j][k])*3+i-x,(d[i][j][k]-d[y][j][k])*3+i-y,d[i][j][k]});
			}
			for(int k=r;k>mid;k--){
				rv.push_back({(d[x][j][k]-d[i][j][k])*3,(d[y][j][k]-d[i][j][k])*3,d[i][j][k]});
			}
		}
		val.push_back(-inf);
		for(auto &t:lv) val.push_back(t[1]);
		for(auto &t:rv) val.push_back(t[1]);
		sort(lv.begin(),lv.end());
		sort(rv.begin(),rv.end());
		sort(val.begin(),val.end());
		for(auto &t:lv) t[1]=lower_bound(val.begin(),val.end(),t[1])-val.begin();
		for(auto &t:rv) t[1]=lower_bound(val.begin(),val.end(),t[1])-val.begin();
		C.lim=S.lim=val.size()-1;
		for(int j=0,k=0;k<rv.size();k++){
			while(j<lv.size()&&lv[j][0]<=rv[k][0]){
				C.Add(lv[j][1],1);
				S.Add(lv[j][1],lv[j][2]);
				j++;
			}
			ans=(ans+C.Ask(rv[k][1])*rv[k][2])%mod;
			ans=(ans+S.Ask(rv[k][1]))%mod;
		}
		C.Clear();
		S.Clear();
	}
	ll md=d[0][2][mid];
	Conquer(l,mid-1,ld,md),Conquer(mid+1,r,md,rd);
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=0;i<n;i++){
		for(int j=1;j<=m;j++) cin>>a[i][j];
	}

	Conquer(1,m,inf,inf);
	ans=(ans<<1)%mod;

	cout<<ans<<endl;

	return 0;
}
```

### 9. Thanks to MikeMirzayanov

æŠŠæ“ä½œçœ‹æˆæ®µå†… reverse å† reverse å…¨éƒ¨ï¼Œå…ˆå¿½ç•¥å…¨å±€çš„ reverseï¼Œæœ€åå¦‚æœæ“ä½œæ¬¡æ•°ä¸ºå¥‡æ•°å†è¡¥ä¸€æ¬¡ã€‚

è€ƒè™‘å¦‚ä½•æ’åºä¸€ä¸ª 01 åºåˆ—ï¼Œå°†ç›¸åŒé¢œè‰²çš„ç¼©åœ¨ä¸€èµ·ï¼Œç„¶åæŠŠ `0 10 1 01 0 10 1` è°ƒæ•´æˆ `0 01 1 10 0 01 1`ï¼Œè¿™æ ·æ¯æ¬¡æ®µæ•°å¯ä»¥é™¤ä»¥ $3$ï¼Œé‡æ–°åˆåˆ°åŸåºåˆ—ä¸Šæ“ä½œæ¬¡æ•°å°±æ˜¯ $O(\log_2n\log_3n)$ çš„ï¼Œå¸¸æ•°å°äº $1$ï¼Œå¯ä»¥é€šè¿‡ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e4+9;

int a[N],n;
vector<vector<int>> ans;

inline void Solve(int l,int r,int s){
	if(l==r) return ;
	int mid=l+r>>1;
	vector<array<int,2>> cur({{a[l]>mid,1}});
	for(int i=l+1;i<=r;i++){
		if((a[i]>mid)==(a[i-1]>mid)) cur.back()[1]++;
		else cur.push_back({!cur.back()[0],1});
	}
	while(cur.size()>2||cur.front()[0]){
		vector<int> tmp;
		vector<array<int,2>> nxt;
		int f=!cur.front()[0];
		for(int i=0;i<cur.size();i++){
			if(i%3==(f+2)%3){
				tmp.push_back(cur[i][1]);
				nxt.push_back(cur[i]);
			}else if(i%3==f){
				if(i+1<cur.size()){
					tmp.push_back(cur[i][1]+cur[i+1][1]);
					nxt.push_back(cur[i+1]);
					nxt.push_back(cur[i]);
				}else{
					tmp.push_back(cur[i][1]);
					nxt.push_back(cur[i]);
				}
			}
		}
		cur.clear();
		for(auto p:nxt){
			if(!cur.size()||cur.back()[0]!=p[0]) cur.push_back(p);
			else cur.back()[1]+=p[1];
		}
		if(s>=ans.size()) ans.resize(ans.size()+1);
		int T=l-1-accumulate(ans[s].begin(),ans[s].end(),0);
		while(T--) ans[s].push_back(1);
		ans[s].insert(ans[s].end(),tmp.begin(),tmp.end());
		int st=l;
		for(int x:tmp){
			reverse(a+st,a+st+x);
			st+=x;
		}
		s++;
	}
	Solve(l,mid,s);
	Solve(mid+1,r,s);
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	Solve(1,n,0);

	for(auto &v:ans){
		int T=n-accumulate(v.begin(),v.end(),0);
		while(T--) v.push_back(1);
	}
	if(ans.size()&1) ans.push_back(vector<int>(n,1));
	for(int i=1;i<ans.size();i+=2) reverse(ans[i].begin(),ans[i].end());

	vector<int> tmp;
	for(int i=ans.size();i--;) if(ans[i].size()==1) tmp.push_back(i);
	for(int i:tmp) ans.erase(ans.begin()+i);

	cout<<ans.size()<<endl;
	for(auto &v:ans){
		cout<<v.size()<<' ';
		for(int x:v) cout<<x<<' ';
		cout<<endl;
	}

	return 0;
}
```

### 10. Excluded Min

ä¸æ˜¯æˆ‘æ“äº†æ•°æ®ç»“æ„æ€ä¹ˆè¿™ä¹ˆéš¾å•Šã€‚

é¦–å…ˆç­”æ¡ˆæ˜¾ç„¶å¯ä»¥è½¬åŒ–æˆ $\displaystyle \max\{v|\sum_{x\in S} [x\lt v]\geq v\}$ï¼Œå…¶ä¸­å¯é‡é›† $S=a[l:r]$ã€‚

è€ƒè™‘ä»å¤§åˆ°å°æ‰«æ $v$ï¼Œé‚£ä¹ˆæœ‰äº› $a_i$ çš„æƒå€¼ä¼šä» $1$ å˜æˆ $0$ï¼Œå¯¹åº”åˆ°å¹³é¢ä¸Šç›¸å½“äºå¯¹ä¸€ä¸ª 2-side çŸ©å½¢å‡ $1$ï¼Œç»´æŠ¤æˆæœ¬å¾ˆé«˜ã€‚

å¦‚æœåªè€ƒè™‘ä¸€äº›ä¸ç›¸äº¤çš„çº¿æ®µï¼Œé‚£ä¹ˆç›¸å½“äºå¯¹ä¸€ä¸ªæ’åºåçš„è¯¢é—®åŒºé—´å‡ $1$ï¼Œè€Œè¿™é¢˜æœ‰æ€§è´¨è¢«åŒ…å«çš„åŒºé—´çš„ç­”æ¡ˆä¸€å®šæ¯”åŒ…å«çš„åŒºé—´çš„å°ã€‚é‚£ä¹ˆå½“ä¸€ä¸ªçº¿æ®µæ±‚å¾—ç­”æ¡ˆä¹‹åæŠŠå®ƒåˆ é™¤å†æ·»åŠ æ–°çš„å…¥åº¦ä¸º $0$ çš„çº¿æ®µå³å¯åšåˆ°æ—¶åˆ»çº¿æ®µä¸ç›¸äº’åŒ…å«ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=5e5+9;
const int inf=1e9+7;

vector<int> b[N];
int a[N],ql[N],qr[N],ans[N],p[N],ip[N],n,q;

multiset<array<int,2>> ls,rs;
namespace Fenw{
	int tr[N];
	inline void Add(int x,int k){while(x<=n) tr[x]+=k,x+=x&-x;}
	inline int Ask(int x){int sum=0;while(x) sum+=tr[x],x&=x-1;return sum;}
	inline int Ask(int l,int r){return Ask(r)-Ask(l-1);}
}
namespace SgT{
	struct Node{
		int tag;
		array<int,2> dat;
	}tr[N<<2];
	inline void PushUp(int x){tr[x].dat=max(tr[x<<1].dat,tr[x<<1|1].dat);}
	inline void Push(int x,int k){tr[x].dat[0]+=k,tr[x].tag+=k;}
	inline void PushDown(int x){
		if(tr[x].tag){
			Push(x<<1,tr[x].tag);
			Push(x<<1|1,tr[x].tag);
			tr[x].tag=0;
		}
	}
	inline void Build(int x,int L,int R){
		if(L==R) return tr[x].dat={-inf,L},void();
		int mid=L+R>>1;
		Build(x<<1,L,mid),Build(x<<1|1,mid+1,R);
		PushUp(x);
	}
	inline void Modify(int x,int L,int R,int l,int r,int k){
		if(l>r) return ;
		if(l<=L&&R<=r) return Push(x,k);
		PushDown(x);
		int mid=L+R>>1;
		if(l<=mid) Modify(x<<1,L,mid,l,r,k);
		if(r>mid) Modify(x<<1|1,mid+1,R,l,r,k);
		PushUp(x);
	}
	inline void Set(int x,int L,int R,int pos,array<int,2> k){
		if(L==R) return tr[x].dat=k,void();
		PushDown(x);
		int mid=L+R>>1;
		if(pos<=mid) Set(x<<1,L,mid,pos,k);
		else Set(x<<1|1,mid+1,R,pos,k);
		PushUp(x);
	}
}
namespace TgS{
	struct Data{
		int a,b,p;
		Data(){}
		Data(int _a,int _b,int _p){a=_a,b=_b,p=_p;}
		inline friend Data operator +(Data x,Data y){
			if(y.b<=x.a) y.b=-inf,y.p=-inf;
			if(x.b>y.b) return Data(max(x.a,y.a),x.b,x.p);
			else return Data(max(x.a,y.a),y.b,y.p);
		}
	};
	struct Node{
		Data dat=Data(-inf,-inf,-inf);
	}tr[N<<2];
	inline void PushUp(int x){tr[x].dat=tr[x<<1].dat+tr[x<<1|1].dat;}
	inline void Set(int x,int L,int R,int pos,Data k){
		if(L==R) return tr[x].dat=k,void();
		int mid=L+R>>1;
		if(pos<=mid) Set(x<<1,L,mid,pos,k);
		else Set(x<<1|1,mid+1,R,pos,k);
		PushUp(x);
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i],a[i]=min(a[i],n);
	for(int i=1;i<=q;i++) cin>>ql[i]>>qr[i];

	iota(p+1,p+q+1,1);
	sort(p+1,p+q+1,[](int i,int j){
		return ql[i]^ql[j]?ql[i]<ql[j]:qr[i]>qr[j];
	});
	for(int i=1;i<=q;i++) ip[p[i]]=i;
	for(int i=1;i<=n;i++) b[a[i]].push_back(i);

	SgT::Build(1,1,q);
	ls.insert({-inf,0});
	rs.insert({inf,q+1});
	for(int i=1;i<=n;i++) Fenw::Add(i,1);
	for(int i=1,j=0;i<=q;i++){
		if(qr[p[i]]<=qr[p[j]]) TgS::Set(1,1,q,i,TgS::Data(-inf,qr[p[i]],i));
		else{
			ls.insert({ql[p[i]],i});
			rs.insert({qr[p[i]],i});
			TgS::Set(1,1,q,i,TgS::Data(qr[p[i]],-inf,-inf));
			SgT::Set(1,1,q,i,{Fenw::Ask(ql[p[i]],qr[p[i]]),i});
			j=i;
		}
	}

	for(int v=n;~v;v--){
		for(int i:b[v]){
			Fenw::Add(i,-1);
			int lp=(*rs.lower_bound({i,0}))[1];
			int rp=(*--ls.lower_bound({i+1,0}))[1];
			SgT::Modify(1,1,q,lp,rp,-1);
		}
		while(SgT::tr[1].dat[0]>=v){
			int i=SgT::tr[1].dat[1];
			ans[p[i]]=v;
			ls.erase({ql[p[i]],i});
			rs.erase({qr[p[i]],i});
			SgT::Set(1,1,q,i,{-inf,i});
			TgS::Set(1,1,q,i,TgS::Data(-inf,-inf,-inf));
			while(true){
				int j=TgS::tr[1].dat.p;
				if(j==-inf) break ;
				TgS::Set(1,1,q,j,TgS::Data(qr[p[j]],-inf,-inf));
				ls.insert({ql[p[j]],j});
				rs.insert({qr[p[j]],j});
				SgT::Set(1,1,q,j,{Fenw::Ask(ql[p[j]],qr[p[j]]),j});
			}
		}
	}

	for(int i=1;i<=q;i++) cout<<ans[i]<<endl;

	return 0;
}
```

### 11./114. Best Subsequence

#### Easy Version (a.k.a. 114. ~)

å…ˆäºŒåˆ†ç­”æ¡ˆ $w$ï¼Œå°†æ•°æŒ‰æ˜¯å¦å¤§äº $\lfloor\dfrac w2\rfloor$ åˆ†ä¸ºå¤§æ•°å’Œå°æ•°ã€‚

é‚£ä¹ˆå°æ•°è‚¯å®šé€‰ï¼Œä¸¤ä¸ªå°æ•°ä¹‹é—´å°±å°è¯•é€‰æœ€å°çš„å¤§æ•°ï¼Œå¦‚æœåˆæ³•å°±åŠ å…¥ç­”æ¡ˆï¼Œè¿™æ ·å°±æ˜¯ $O(n\log V)$ çš„ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=5e5+9;

int a[N],n,k;

inline int Count(int w){
	int cnt=0;
	for(int i=1;i<=n;i++) if(a[i]<=(w>>1)) cnt++;
	if(!cnt) return 0;
	int lp=n,rp=0;
	for(int i=1;i<=n;i++){
		if(a[i]>(w>>1)) continue ;
		if(!rp) lp=rp=i;
		else{
			if(rp+1<i){
				int k=*min_element(a+rp+1,a+i);
				if(ll(max(a[i],a[rp]))+k<=w) cnt++;
			}
			rp=i;
		}
	}
	int k=2e9;
	if(lp!=1) k=min(k,*min_element(a+1,a+lp));
	if(rp!=n) k=min(k,*min_element(a+rp+1,a+n+1));
	if(ll(max(a[lp],a[rp]))+k<=w) cnt++;
	return cnt;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];

	int L=-1,R=2e9+1;
	while(L+1<R){
		int mid=ll(L)+R>>1;
		if(Count(mid)>=k) R=mid;
		else L=mid;
	}

	cout<<R<<endl;

	return 0;
}
```

#### Hard Version (a.k.a. 11. ~)

è€ƒè™‘æœ‰å¤šæ¬¡è¯¢é—®æ€ä¹ˆåšã€‚

å°è¯•æ‰¾å‡ºæ‰€æœ‰å°æ•°-å¤§æ•°-å°æ•°æœ‰æ•ˆç»„åˆ $(i,j,k)$ï¼Œè¿™ä¼šå¯¹ $w\in[\max(a_i,a_k)+a_j,2a_j)$ äº§ç”Ÿ $1$ çš„è´¡çŒ®ã€‚ç”±äº $(i,k)$ ä¸­ä¸å­˜åœ¨ $a_p<a_j$ çš„ $p$ï¼Œå› æ­¤ $a_i,a_k$ åˆ†åˆ«ä¸º $j$ å·¦å³ç¬¬ä¸€ä¸ªæ¯” $a_j$ å°çš„æ•°ï¼Œå•è°ƒæ ˆæ‰¾å‡ºå³å¯ã€‚

è€ƒè™‘å¯¹å€¼åŸŸå»ºå‡ºå¯æŒä¹…åŒ–çº¿æ®µæ ‘ï¼Œå°æ•°çš„è´¡çŒ®æ˜¯å®¹æ˜“ç»´æŠ¤çš„ã€‚$(i,j,k)$ å¯¹çš„è€ƒè™‘å…¨éƒ¨è®°åœ¨ $k$ çš„ä½ç½®ï¼Œå¯¹äºè¯¢é—® $[l,r]$ï¼Œåˆ†åˆ«æ‰¾å‡ºå…¶æœ€å·¦æœ€å³çš„å°æ•° $a_L,a_R$ï¼Œé‚£ä¹ˆç”±äº $a_L$ æ˜¯å°æ•°ï¼Œé‚£ä¹ˆ $k\in(L,R]$ çš„ $(i,j,k)$ å¿…ç„¶æ»¡è¶³ $l\leq L\leq i,j,k\leq R\leq r$ã€‚å‰©ä¸‹æ–­ç¯ä¸ºé“¾ä¸¢å¤±çš„è´¡çŒ®æœ€åè¡¥ä¸Šå³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log V+q\log^2 V)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e5+9;
const int lgN=2e1;
const int inf=2e9;

int a[N],mn[lgN][N],n,q;
inline void InitRMQ(){
	for(int i=1;i<=n;i++) mn[0][i]=a[i];
	for(int k=1;k<=__lg(n);k++){
		for(int i=1;i+(1<<k)-1<=n;i++){
			mn[k][i]=min(mn[k-1][i],mn[k-1][i+(1<<k-1)]);
		}
	}
}
inline int Min(int l,int r){
	if(l>r) return inf;
	int k=__lg(r-l+1);
	return min(mn[k][l],mn[k][r-(1<<k)+1]);
}

struct Node{
	int lc,rc,dat;
}tr[N<<7];

int root[N],cnt;
inline int Allc(){return ++cnt;}
inline int Clone(int x){int y=Allc();tr[y]=tr[x];return y;}
inline void PushUp(int x){tr[x].dat=tr[tr[x].lc].dat+tr[tr[x].rc].dat;}
inline void Modify(int &x,int L,int R,int pos,int k){
	x=Clone(x);
	if(L==R) return tr[x].dat+=k,void();
	int mid=ll(L)+R>>1;
	if(pos<=mid) Modify(tr[x].lc,L,mid,pos,k);
	else Modify(tr[x].rc,mid+1,R,pos,k);
	PushUp(x);
}
inline int Query(int x,int L,int R,int l,int r){
	if(!x) return 0;
	if(l<=L&&R<=r) return tr[x].dat;
	int mid=ll(L)+R>>1,ans=0;
	if(l<=mid) ans+=Query(tr[x].lc,L,mid,l,r);
	if(r>mid) ans+=Query(tr[x].rc,mid+1,R,l,r);
	return ans;
}

inline int LApr(int p,int k){
	int l=p-1,r=n+1;
	while(l+1<r){
		int mid=l+r>>1;
		if(Min(p,mid)<=k) r=mid;
		else l=mid;
	}
	return r;
}
inline int RApr(int p,int k){
	int l=0,r=p+1;
	while(l+1<r){
		int mid=l+r>>1;
		if(Min(mid,p)<=k) l=mid;
		else r=mid;
	}
	return l;
}
inline int Count(int l,int r,int w){
	int lp=LApr(l,w>>1),rp=RApr(r,w>>1),ans=0;
	if(lp>r||rp<l) return ans;
	ans+=Query(root[rp],0,inf,0,w)-Query(root[lp],0,inf,0,w)+1;
	ans+=(ll(min(Min(l,lp-1),Min(rp+1,r)))+max(a[lp],a[rp])<=w);
	return ans;
}
inline int Calc(int l,int r,int k){
	int L=-1,R=inf+1;
	while(L+1<R){
		int mid=ll(L)+R>>1;
		if(Count(l,r,mid)>=k) R=mid;
		else L=mid;
	}
	return R;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];

	InitRMQ();
	vector<int> stk;
	for(int i=1;i<=n;i++){
		Modify(root[i]=root[i-1],0,inf,a[i]<<1,1);
		while(stk.size()&&a[stk.back()]>=a[i]){
			if(stk.size()>1){
				int j=stk.end()[-1],k=stk.end()[-2];
				Modify(root[i],0,inf,a[j]+max(a[i],a[k]),1);
				Modify(root[i],0,inf,a[j]<<1,-1);
			}
			stk.pop_back();
		}
		stk.push_back(i);
	}

	while(q--){
		int l,r,k;
		cin>>l>>r>>k;
		cout<<Calc(l,r,k)<<endl;
	}
	
	return 0;
}
```

### 12. Binary Search Tree

é¦–å…ˆæŠŠæ•°æ‰”åˆ°å€¼åŸŸä¸Šçœ‹å°±æ˜¯ä»¥æ’å…¥æ—¶é—´ä¸º prio çš„ç¬›å¡å°”æ ‘ã€‚

è€Œç¬›å¡å°”æ ‘ä¸Šçš„å·¦çˆ¶äº²å’Œå³çˆ¶äº²åˆ†åˆ«å°±æ˜¯å‰ç¼€/åç¼€æœ€å°å€¼ã€‚

é‚£ä¹ˆç¦»çº¿ä¸‹æ¥ç›´æ¥æ¥¼æˆ¿é‡å»ºç»´æŠ¤å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n\log^2 n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e5+9;
const int inf=1e9+7;

ll ans[N];
int op[N],w[N],t[N],n,q,tot;
vector<array<int,2>> opr[N];
vector<int> qry[N],val;

struct SgT{
	struct Node{
		int l,r;
		ll mn,sum;
	}tr[N<<2];

	inline ll Calc(int x,int k){
		if(k<=tr[x].mn) return 0;
		if(tr[x].l==tr[x].r) return w[tr[x].mn];
		if(k<=tr[x<<1|1].mn) return Calc(x<<1,k);
		else return Calc(x<<1|1,k)+tr[x].sum-tr[x<<1|1].sum;
	}
	inline void PushUp(int x){
		tr[x].mn=min(tr[x<<1].mn,tr[x<<1|1].mn);
		tr[x].sum=tr[x<<1|1].sum+Calc(x<<1,tr[x<<1|1].mn);
	}
	inline void Build(int x,int l,int r){
		tr[x].l=l,tr[x].r=r;
		if(tr[x].l==tr[x].r) return tr[x].mn=q+1,void();
		int mid=tr[x].l+tr[x].r>>1;
		Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
		PushUp(x);
	}
	inline void Set(int x,int pos,int k){
		if(tr[x].l==tr[x].r) return tr[x].mn=k,tr[x].sum=w[k],void();
		int mid=tr[x].l+tr[x].r>>1;
		if(pos<=mid) Set(x<<1,pos,k);
		else Set(x<<1|1,pos,k);
		PushUp(x);
	}
	inline array<ll,2> Prefix(int x,int pos,ll k){
		if(pos<tr[x].l) return {0,q+1};
		if(tr[x].l==tr[x].r) return {Calc(x,k),min(k,tr[x].mn)};
		int mid=tr[x].l+tr[x].r>>1;
		if(pos<=mid) return Prefix(x<<1,pos,k);
		else{
			auto res=Prefix(x<<1|1,pos,k);
			return {res[0]+Calc(x<<1,res[1]),min(res[1],tr[x<<1].mn)};
		}
	}
}T,R;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1,l,r,x;i<=q;i++){
		cin>>op[i];
		if(op[i]==1){
			cin>>l>>r>>w[i];
			opr[l].push_back({w[i],i});
			opr[r+1].push_back({w[i],q+1});
		}else{
			cin>>x>>w[i];
			qry[x].push_back(i);
		}
		val.push_back(w[i]);
	}

	val.push_back(0);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()),val.end());
	tot=val.size()-1;
	
	w[q+1]=inf;
	T.Build(1,1,tot);
	R.Build(1,1,tot);
	for(int i=1;i<=tot;i++) t[i]=q+1;
	for(int i=1;i<=n;i++){
		for(auto p:opr[i]){
			p[0]=lower_bound(val.begin(),val.end(),p[0])-val.begin();
			T.Set(1,p[0],p[1]);
			R.Set(1,tot-p[0]+1,p[1]);
			t[p[0]]=p[1]+1;
		}
		for(int j:qry[i]){
			int p=lower_bound(val.begin(),val.end(),w[j])-val.begin();
			ans[j]=T.Prefix(1,p,min(j,t[p]))[0]+R.Prefix(1,tot-p,min(j,t[p]))[0];
		}
	}

	for(int i=1;i<=q;i++) if(op[i]==2) cout<<ans[i]<<endl;

	return 0;
}
```

### 13. Game

é€‰æ‰‹æ³¨æ„åŠ›æ¶£æ•£å’‹åŠã€‚

è€ƒè™‘ $(1,n)$ ä¸­æœ€å¤§å€¼çš„å†³ç­–ï¼Œè®¾å…¶ä½ç½®ä¸º $x$ï¼Œé‚£ä¹ˆå¯¹äº $x$ æ¥è¯´ï¼Œå¦‚æœä¸åœ¨ $x$ åœç•™ï¼Œæœ€ååœ¨ $(1,n)$ åœç•™è‚¯å®šä¸ä¼˜ï¼Œå› æ­¤åªèƒ½èµŒè·‘åˆ°ä¸€ä¸ª $1$ æˆ– $n$ å¤„çš„è¾ƒå¤§å€¼ï¼Œé‚£ä¹ˆæ­¤æ—¶çš„æœŸæœ› $E(x)=(1-P(x))A_1+P(x)A_n$ï¼Œå…¶ä¸­ $P(x)$ è¡¨ç¤ºä» $x$ å‡ºå‘åœç•™åœ¨ $n$ çš„æ¦‚ç‡ã€‚

å¯ä»¥è¯æ˜çš„æ˜¯ï¼Œ$P(x)=\dfrac {x-1}{n-1}$ã€‚è€ƒè™‘åˆ—å‡º $P$ çš„å…³ç³»å¼ï¼Œå³ $P(x)=\dfrac {P(x-1)+P(x+1)}2$ï¼Œç»è¿‡ç®€å•å˜å½¢å³å¯å‘ç° $P$ æ˜¯ç­‰å·®æ•°åˆ—ï¼Œå¸¦å…¥è¾¹ç•Œ $P(1)=0,P(n)=1$ å³å¯å¾—å‡º $P(x)=\dfrac{x-1}{n-1}$ã€‚å› æ­¤ï¼Œè‹¥ $A_x\gt \dfrac {n-x}{n-1} A_1+\dfrac {x-1}{n-1} A_n$ï¼Œåˆ™ $x$ ä¹Ÿæ˜¯å¿…é€‰ç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥å¯¹ $[1,x]$ å’Œ $[x,n]$ åšç›¸åŒçš„äº‹ï¼Œå¦åˆ™ç­”æ¡ˆå°±æ˜¯ $\displaystyle \frac 1n\sum_{x=1}^nE(x)$ã€‚

ä¸éš¾è§‚å¯Ÿåˆ°ï¼Œä¸Šé¢çš„ç­”æ¡ˆç­‰åŒäº $\dfrac 1n$ å€çš„å‡¸åŒ…é¢ç§¯ï¼Œç›´æ¥æ±‚å‡ºå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n)$ã€‚

å½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥é’¦å®šå¿…é€‰ç‚¹ $1=x_1\lt x_2\lt \ldots \lt x_m=n$ï¼Œè§‚å¯Ÿç­”æ¡ˆ $\displaystyle \frac 1{2n}(A_1+\sum_{i=1}^{m-1}(A_{x_i}+A_{x_{i+1}})(x_{i+1}-x_i)+A_n)$ å¾—å‡ºç»“è®ºã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=5e5+9;
const int mod=998244353;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

int n;
ll a[N];

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	vector<int> stk;
	for(int i=1;i<=n;i++){
		while(stk.size()>1){
			int j=stk.end()[-1],k=stk.end()[-2];
			if((a[i]-a[j])*(j-k)>=(a[j]-a[k])*(i-j)) stk.pop_back();
			else break ;
		}
		stk.push_back(i);
	}

	int ans=0;
	for(int i=0;i+1<stk.size();i++) AddAs(ans,Mul((a[stk[i]]+a[stk[i+1]])%mod,stk[i+1]-stk[i]));
	AddAs(ans,(a[stk.front()]+a[stk.back()])%mod);
	MulAs(ans,Inv(Mul(2,n)));
	
	cout<<ans<<endl;

	return 0;
}
```

### 14. Local Maxima

è€ƒè™‘ä»å¤§åˆ°å°å¡«è§„é¿æ‰é™åˆ¶ï¼Œé‚£ä¹ˆç›¸å½“äºæ¯æ¬¡åªèƒ½å¡«å’Œä¹‹å‰å¡«çš„åŒè¡Œæˆ–è€…åŒåˆ—çš„ã€‚

è®¾ $f_{i,j}$ è¡¨ç¤ºå·²ç»å¡«äº† $i$ è¡Œ $j$ åˆ—å…± $ij$ ä¸ªäº¤å‰ç‚¹ï¼Œæœ‰è½¬ç§»ï¼š

-   $\displaystyle f_{i+1,j} \leftarrow (n-i)\binom{nm-ij-1}{j-1}j!f_{i,j}$ã€‚
-   $\displaystyle f_{i,j+1}\leftarrow (m-j)\binom{nm-ij-1}{i-1}i!f_{i,j}$ã€‚

åˆå€¼æœ‰ $f_{1,1}=1$ï¼Œç­”æ¡ˆå°±æ˜¯ $f_{n,m}$ã€‚

äº‹å®ä¸Šæœ‰æ›´åŠ é«˜æ˜çš„åšæ³•ï¼Œ è€ƒè™‘äºŒé¡¹å¼åæ¼”ï¼Œé’¦å®šæœ‰ $i$ ä¸ªæœ€å¤§å€¼ï¼Œä»¤æ°æœ‰ $k$ ä¸ªå±€éƒ¨æœ€å¤§å€¼çš„ç­”æ¡ˆä¸º $f_k$ï¼Œåˆ™ï¼š

-   è®¾ $\displaystyle a_i=n+m-2i,s_i=\sum_{j=1}^ia_j$ã€‚

-   $\displaystyle f_k=\sum_{i=k}^{\min(n,m)}(-1)^{i-k}\binom{i}{k}\binom{nm}{s_i+i}(nm-s_i-i)!\binom ni\binom mi(i!)^2\prod_{j=1}^i\binom{s_j+j-1}{a_j}a_j!$ã€‚

$f_1$ å³ä¸ºæ‰€æ±‚ã€‚

æ—¶é—´å¤æ‚åº¦å‡ä¸º $O(nm)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e3+9;

int mod;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

int fac[N*N],ifac[N*N];
inline void Init(int lim){
	fac[0]=1;
	for(int i=1;i<=lim;i++) fac[i]=Mul(fac[i-1],i);
	ifac[lim]=Inv(fac[lim]);
	for(int i=lim-1;~i;i--) ifac[i]=Mul(ifac[i+1],i+1);
}
inline int C(int n,int m){
	if(m<0||m>n) return 0;
	else return Mul(fac[n],Mul(ifac[m],ifac[n-m]));
}

int f[N][N],n,m;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m>>mod;

	Init(n*m);
	f[1][1]=n*m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++){
			AddAs(f[i+1][j],Mul(f[i][j],Mul(n-i,Mul(C(n*m-i*j-1,j-1),fac[j]))));
			AddAs(f[i][j+1],Mul(f[i][j],Mul(m-j,Mul(C(n*m-i*j-1,i-1),fac[i]))));
		}
	}

	cout<<f[n][m]<<endl;

	return 0;
}
```

### 16. Designing a PCB

æ¯ä¸ªè§¦ç‚¹æœ€åŸºæœ¬çš„åªæœ‰å‘ä¸Šæˆ–è€…å‘ä¸‹ä¸¤ç§æ¨¡å¼ï¼Œå¯¹äºä¸€å¯¹æ–¹å‘ä¸åŒçš„è§¦ç‚¹å‘å·¦ç»•å’Œå‘å³ç»•æ²¡æœ‰ä»€ä¹ˆæœ¬è´¨åŒºåˆ«ï¼Œå› æ­¤ç›´æ¥é’¦å®šå‘å·¦ç»•ã€‚

è€ƒè™‘è§¦ç‚¹ $(l_1,r_1),(l_2,r_2)$ ä¹‹é—´çš„å…³ç³»ï¼Œä¸å¤±ä¸€èˆ¬æ€§åœ°è®¤ä¸º $l_1<l_2$ï¼š

-   è‹¥ $r_1<l_2$ï¼Œåˆ™æ— é™åˆ¶ã€‚
-   è‹¥ $l_2<r_1<r_2$ï¼Œç®€å•åœ°æšä¸¾æƒ…å†µå‘ç°è§¦ç‚¹ $l_2$ å’Œ $r_1$ çš„çŠ¶æ€å¿…ç„¶ä¸åŒã€‚
-   è‹¥ $r_1>r_2$ï¼Œé‚£ä¹ˆè§¦ç‚¹ $l_2$ å’Œ $r_2$ çš„çŠ¶æ€ä¸€å®šç›¸åŒã€‚

å› æ­¤å¯ä»¥æ ¹æ®è¿™äº›é™åˆ¶è¿›è¡ŒäºŒåˆ†å›¾æŸ“è‰²ï¼Œæ‰¾å‡ºä¸€ç»„ç‰¹è§£è¾“å‡ºå³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n^2)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e3+9;

vector<array<int,2>> e[N];
int p[N],l[N],r[N],c[N],h[N],n;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=2*n;i++){
		cin>>p[i];
		swap(l[p[i]],r[p[i]]);
		r[p[i]]=i;
	}

	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++){
			if(i==j) continue ;
			if(l[i]>l[j]) continue ;
			if(r[i]<l[j]) continue ;
			if(r[i]<r[j]){
				e[l[j]].push_back({r[i],1});
				e[r[i]].push_back({l[j],1});
			}else{
				e[l[j]].push_back({r[j],0});
				e[r[j]].push_back({l[j],0});
			}
		}
	}

	memset(c,-1,sizeof c);
	queue<int> q;
	for(int i=1;i<=2*n;i++){
		if(!~c[i]){
			c[i]=0;
			q.push(i);
			while(q.size()){
				int x=q.front();
				q.pop();
				for(auto p:e[x]){
					int w=c[x]^p[1];
					if(~c[p[0]]){
						if(c[p[0]]!=w){
							cout<<"NO"<<endl;
							return 0;
						}
					}else{
						c[p[0]]=w;
						q.push(p[0]);
					}
				}
			}
		}
	}

	for(int i=1;i<=2*n;i++){
		if(i!=r[p[i]]) continue ;
		for(int j=c[l[p[i]]]==c[r[p[i]]]?l[p[i]]:1;j<=r[p[i]];j++) h[p[i]]=max(h[p[i]],h[p[j]]);
		h[p[i]]++;
	}

	cout<<"YES"<<endl;
	for(int i=1;i<=n;i++){
		if(!c[l[i]]&&!c[r[i]]) cout<<3<<" U "<<h[i]<<" R "<<r[i]-l[i]<<" D "<<h[i]<<endl;
		else if(!c[l[i]]&&c[r[i]]) cout<<5<<" U "<<h[i]<<" L "<<l[i]+h[i]<<" D "<<2*h[i]<<" R "<<h[i]+r[i]<<" U "<<h[i]<<endl;
		else if(c[l[i]]&&!c[r[i]]) cout<<5<<" D "<<h[i]<<" L "<<l[i]+h[i]<<" U "<<2*h[i]<<" R "<<h[i]+r[i]<<" D "<<h[i]<<endl;
		else cout<<3<<" D "<<h[i]<<" R "<<r[i]-l[i]<<" U "<<h[i]<<endl;
	}

	return 0;
}
```

### 17. Knowledge Is...

æ‚”æ‚”ï¼ï¼Ÿ

ç›¸å½“äºå°½é‡åŒ¹é…æ— äº¤çš„åŒºé—´ã€‚æŠŠæ‰€æœ‰åŒºé—´æŒ‰ $L_i$ æ’åºï¼Œç»´æŠ¤å¾…å®šé›†åˆå’Œå·²åŒ¹é…é›†åˆï¼Œå› ä¸ºå·¦ç«¯ç‚¹æœ‰åºï¼Œæ¯æ¬¡åŒ¹é…å¾…å®šçš„ $R_i$ æœ€å°çš„ã€‚å¦‚æœæ²¡æœ‰åˆ™åŒ¹é…ä»¥åŒ¹é…çš„é å³çš„åŒºé—´å³ç«¯ç‚¹æœ€å°çš„ï¼Œæ¢å‡ºæ¥ä¸€ä¸ªå³ç«¯ç‚¹æ›´å°çš„ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=3e5+9;

int l[N],r[N],b[N],c[N],n,m;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>l[i]>>r[i];

	vector<int> p(n);
	iota(p.begin(),p.end(),1);
	sort(p.begin(),p.end(),[](int i,int j){return l[i]<l[j];});

	priority_queue<array<int,2>> q1,q2;
	for(int i:p){
		if(q1.size()&&l[i]>-q1.top()[0]){
			int j=q1.top()[1];
			q1.pop();
			b[i]=j,b[j]=i;
			q2.push({-r[i],i});
		}else if(q2.size()&&r[i]>-q2.top()[0]){
			int j=q2.top()[1],k=b[j];
			q2.pop();
			b[i]=k,b[k]=i,b[j]=0;
			q2.push({-r[i],i});
			q1.push({-r[j],j});
		}else q1.push({-r[i],i});
	}

	for(int i=1;i<=n;i++) if(!c[i]&&b[i]&&m) c[i]=c[b[i]]=m--;
	for(int i=1;i<=n;i++) if(!c[i]&&m) c[i]=m--;

	for(int i=1;i<=n;i++) cout<<c[i]<<' ';cout<<endl;

	return 0;
}
```

### 18. Lights On The Road

å¦‚æœæ˜¯æœ€å¤§åˆ™å¯ä»¥è¶…çº§é’¢ç´ï¼Œæœ€å°ä¸æ˜¯å¾ˆå¥½åˆ»ç”»ï¼Œå› æ­¤è€ƒè™‘ç›´æ¥å¯¹ DP çŠ¶æ€è¿›è¡Œå›¾è®ºå»ºæ¨¡ï¼Œè·‘ $k$ çŸ­è·¯ã€‚

$k$ çŸ­è·¯å³ï¼š

-   æ‰¾å‡ºåŸæœ‰å‘å›¾æœ€çŸ­è·¯æ ‘ï¼Œåˆ™ä¸€ç»„æ»¡è¶³æŸé¡¹èµ·ç‚¹æ˜¯ä¸Šä¸€é¡¹ç»ˆç‚¹éæ ‘è¾¹åºåˆ—ä¸ $S\rightsquigarrow T$ çš„ä¸€æ¡è·¯å¾„æ„æˆåŒå°„ã€‚
-   é‚£ä¹ˆç»´æŠ¤æ¯ä¸ªèŠ‚ç‚¹ä½œä¸ºèµ·ç‚¹çš„éæ ‘è¾¹é›†åˆï¼Œåˆ©ç”¨å¯æŒä¹…åŒ–å¯å¹¶å †ä¸‹æ”¾åˆ°å­æ ‘å†…çš„èŠ‚ç‚¹ï¼Œç„¶åä» $S$ å¼€å§‹è¶…çº§é’¢ç´ã€‚

æ—¶é—´å¤æ‚åº¦ $O((n+k)\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e5+9;
const ll inf=1e18;


ll dis[N];
int fi[N],ne[N<<2],to[N<<2],w[N<<2],adj;
inline void AddEdge(int x,int y,int z){
	ne[++adj]=fi[x];
	fi[x]=adj;
	to[adj]=y;
	w[adj]=z;
}

struct Node{
	int dat,lc,rc;
}tr[N<<6];

int cnt;
mt19937 rng(4649);
inline int Allc(){return ++cnt;}
inline int Allc(int k){int x=Allc();tr[x].dat=k;return x;}
inline int Clone(int x){int y=Allc();tr[y]=tr[x];return y;}
inline int Merge(int x,int y){
	if(!x||!y) return x|y;
	if(w[tr[x].dat]>w[tr[y].dat]) swap(x,y);
	x=Clone(x);
	if(rng()&1) swap(tr[x].lc,tr[x].rc);
	tr[x].rc=Merge(tr[x].rc,y);
	return x;
}
inline int Pop(int x){return Merge(tr[x].lc,tr[x].rc);}

int a[N],fa[N],root[N],n,k,s,t;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>k;
	for(int i=1;i<=n;i++) cin>>a[i];

	s=0,t=n+1;
	for(int i=1;i<=n;i++){
		for(int k:{1,2,3}) if(i-k>0) AddEdge(i-k,i,a[i]);
	}
	for(int i=1;i<=min(n,2);i++){
		AddEdge(s,i,a[i]);
		AddEdge(n-i+1,t,0);
	}

	for(int i=s;i<=t;i++) dis[i]=inf;
	dis[t]=0;
	for(int x=n;x>=s;x--){
		for(int i=fi[x];i;i=ne[i]){
			int y=to[i];
			if(dis[y]+w[i]<dis[x]){
				dis[x]=dis[y]+w[i];
				fa[x]=y;
			}
		}
	}
	for(int x=t;x>=s;x--){
		for(int i=fi[x];i;i=ne[i]){
			int y=to[i];
			if(y==fa[x]) continue ;
			w[i]+=-dis[x]+dis[y];
			root[x]=Merge(root[x],Allc(i));
		}
		root[x]=Merge(root[x],root[fa[x]]);
	}

	cout<<dis[s]<<endl,k--;
	priority_queue<pair<ll,int>> q;
	if(root[s]) q.push({-(dis[s]+w[tr[root[s]].dat]),root[s]});
	while(q.size()&&k-->0){
		int x=q.top().second;
		ll sum=-q.top().first;
		q.pop();
		cout<<sum<<endl;
		int i=tr[x].dat;
		if(root[to[i]]) q.push({-(sum+w[tr[root[to[i]]].dat]),root[to[i]]});
		for(int y:{tr[x].lc,tr[x].rc}){
			if(y) q.push({-(sum-w[tr[x].dat]+w[tr[y].dat]),y});
		}
	}
	while(k-->0) cout<<-1<<endl;

	return 0;
}
```

### 19. Koosaga's Problem

ç”±äºè¦æ±‚è¾¹æ•°æœ€å°‘ï¼Œå› æ­¤åˆ è¾¹å’ŒæŠŠè¾¹æƒå˜ä¸º $0$ ç­‰ä»·ã€‚è€Œå›¾ä¸Šæ²¡æœ‰å¥‡ç¯ç­‰ä»·äºéæ ‘è¾¹æ„æˆçš„ç¯æ²¡æœ‰å¥‡ç¯ï¼Œå› æ­¤è€ƒè™‘ç»™æ¯ä¸ªç¯éšæœºèµ‹æƒï¼Œåˆ™ç›®æ ‡ä¸ºæ‰¾å‡ºä¸€ä¸ªè¾¹é›†ä½¿å¾—å¼‚æˆ–å’Œæ°ä¸ºæ‰€æœ‰å¥‡ç¯çš„æƒçš„å¼‚æˆ–å’Œï¼Œè¿™æ˜¯å¯ä»¥ç”¨ map ç®€å•å®ç°çš„ã€‚æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
using ull=unsigned long long;
const int N=3e5+9;

ull d[N],w[N];
vector<int> e[N];
int u[N],v[N],up[N],fa[N],vis[N],dep[N],n,m;
inline void DFS1(int x){
	vis[x]=1;
	for(int i:e[x]){
		int y=x^u[i]^v[i];
		if(vis[y]) continue ;
		fa[y]=x,up[y]=i;
		dep[y]=dep[x]+1;
		DFS1(y);
	}
}
inline void DFS2(int x){
	for(int i:e[x]){
		int y=x^u[i]^v[i];
		if(fa[y]!=x) continue ;
		DFS2(y);
		d[x]^=d[y];
	}
	w[up[x]]=d[x];
}

mt19937_64 rng(4649);

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>u[i]>>v[i];
		e[u[i]].push_back(i);
		e[v[i]].push_back(i);
	}

	ull s=0;
	DFS1(1);
	for(int i=1;i<=m;i++){
		if(abs(dep[u[i]]-dep[v[i]])<=1) continue ;
		w[i]=rng();
		d[u[i]]^=w[i];
		d[v[i]]^=w[i];
		if(~(dep[u[i]]+dep[v[i]])&1) s^=w[i];
	}
	DFS2(1);

	if(!s) cout<<1<<endl;
	else{
		ll ans1=0,ans2=0;
		map<ull,int> cnt;
		for(int i=1;i<=m;i++){
			if(w[i]==s) ans1++;
			else ans2+=cnt[s^w[i]];
			cnt[w[i]]++;
		}
		cout<<(ans1?ans1:ans2)<<endl;
	}

	return 0;
}
```

### 20. Rhythm Game

è®¾ $f_{i,j}$ è¡¨ç¤ºå½“å‰è€ƒè™‘åˆ°ç¬¬ $i$ ä½ï¼Œæ¼äº† $j$ ä¸ªéŸ³ç¬¦ä¸” $i$ æ²¡æ•²çš„æœ€å¤§æ”¶ç›Šï¼Œæœ‰ 2D/1D è½¬ç§»ï¼š$\displaystyle f_{i,j}=\max_{k=1}^{i-1} \big(f_{k,j-1}+w(k,i)\big)$ï¼Œå…¶ä¸­ $\displaystyle w(k,i)=\sum_{d=k+1}^{i-1}A_dC_{d-k}+P[k\neq i-1]$ã€‚

ä¸éš¾å‘ç°ï¼Œ$k\lt i-1$ çš„ $w(k,i)$ æ»¡è¶³å››è¾¹å½¢ä¸ç­‰å¼ï¼Œå¯ä»¥å†³ç­–å•è°ƒæ€§ä¼˜åŒ–ï¼Œ$k=i-1$ å•ç‹¬è½¬ç§»å³å¯ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n^2\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e3+9;
const ll inf=1e18;

ll f[N],g[N],w[N][N];
int a[N],c[N],n,k,p;

inline void Work(int l,int r,int L,int R){
	if(l>r) return ;
	int mid=l+r>>1,p=-1;
	g[mid]=-inf;
	for(int i=max(0,L);i<=min(R,mid-2);i++){
		if(f[i]+w[i][mid]>g[mid]){
			g[mid]=f[i]+w[i][mid];
			p=i;
		}
	}
	Work(l,mid-1,L,p);
	Work(mid+1,r,p,R);
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>k>>p;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>c[i];

	for(int i=0;i<=n;i++){
		for(int j=i+1;j<=n;j++) w[i][j+1]=w[i][j]+1ll*c[j-i]*a[j];
	}

	ll ans=-inf;
	for(int i=1;i<=n+1;i++) f[i]=-inf;
	for(int i=0;i<=n+1;i++) g[i]=-inf;
	for(int o=1;o<=n+1;o++){
		Work(o+1,n+1,0,n);
		for(int i=o;i<=n+1;i++) g[i]=max(g[i]+p,f[i-1]);
		if(n+1-o<=k) ans=max(ans,g[n+1]);
		for(int i=0;i<=n+1;i++) f[i]=exchange(g[i],-inf);
	}

	cout<<ans<<endl;

	return 0;
}
```

### 21. Stone Catch Game

é¦–å…ˆåªæœ‰ä¸€ä¸ªç‚¹å°±æ˜¯åªæœ‰ $(n,n)$ çš„æƒ…å†µé»‘æ–¹èƒœå‡ºã€‚

é€šè¿‡æ‰‹ç©å¤§é‡æ•°æ®ï¼Œå‘ç°äº‹å®ä¸Š $x=y$ å·¦è¾¹å’Œå³è¾¹åˆ†åˆ«åªä¼šæœ‰ä¸€ä¸ªæœ‰æ•ˆçš„ç‚¹ï¼Œå› ä¸ºè¿™ä¸¤è¾¹åˆ†åˆ«é™åˆ¶äº†ç™½æ£‹å‘ä¸Š/å³é€ƒé€¸ï¼Œå› æ­¤åŒä¸€æ–¹å‘æ²¡å¿…è¦ç”¨ä¸¤ä¸ªæ£‹å­é™åˆ¶ã€‚æ•…ä¸å¦¨å…ˆè€ƒè™‘åªæœ‰ä¸¤ä¸ªæ£‹å­çš„æƒ…å†µã€‚

è€ƒè™‘ä»é»‘æ£‹å‘å…¶å³ä¸‹ç”»å‡ºå…¶æ§åˆ¶çº¿ï¼Œå³ç™½æ£‹è‹¥ç¢°åˆ°æ§åˆ¶çº¿åˆ™å¯ä»¥è½¬åŒ–åˆ° $(n,n)$ çš„æƒ…å†µã€‚å¹¶ä¸”è´ªå¿ƒåœ°ï¼Œ$x<y$ çš„é»‘æ£‹ï¼ˆç§°ä¸º $(x_1,y_1)$ï¼‰åªä¼šå‘ä¸‹ç§»åŠ¨ï¼Œ$x>y$ çš„é»‘æ£‹ï¼ˆç§°ä¸º $(x_2,y_2)$ï¼‰åªä¼šå‘å·¦ç§»åŠ¨ã€‚ç‰¹åˆ«åœ°ï¼Œæš‚ä¸”å…ˆè®¤ä¸º $x_1\leq x_2,y_2\leq y_1$ã€‚

æ ¹æ®æ§åˆ¶çº¿çš„è½¨è¿¹ï¼Œè‹¥ç™½æ£‹å¤„äº $x\leq x_1,y\leq y_2$ çš„éƒ¨åˆ†åˆ™ä»æœªè„±ç¦»æ§åˆ¶ï¼Œç™½æ£‹ä¸ºäº†è„±ç¦»æ§åˆ¶ä¸€å®šä¼šå‘ $(x_1+1,y_2+1)$ ç§»åŠ¨ã€‚é€€ä¸¤æ­¥è¯´ï¼Œå½“ç™½æ£‹ä½äº $x+y=x_1+y_2$ æ—¶ï¼Œé»‘æ£‹çš„ç†æƒ³ä½ç½®æ˜¯ $(x_1,y_2+2)$ å’Œ $(x_1+2,y_2)$ æˆ–æ›´æ·±ã€‚å› ä¸º $(x_1,y_2)$ è¢«ç›´æ¥æ§åˆ¶ï¼Œè€Œå‰©ä¸‹çš„ç‚¹åˆ™ä½äºæ§åˆ¶çº¿ä¹‹å¤–ï¼Œè‹¥æ˜¯é€€ä¸€æ­¥åˆ™æ ¹æ®é»‘æ£‹çš„ä½ç½®ä»¥åŠç™½æ£‹æ–¹å‘çš„é€‰æ‹©æœ‰åˆ†è®¨ä»¥åŠä¸ä¾¿ã€‚å› æ­¤åœ¨ç™½æ£‹æŠµè¾¾ $(x_1,y_2)$ ä¹‹å‰é»‘æ£‹éœ€è¾¾åˆ°ç†æƒ³ä½ç½®ï¼Œå³ï¼š$\max(y_1-y_2-2,0)+\max(x_2-x_1-2,0)\leq x_1+y_2$ åˆ™é»‘æ–¹èƒœå‡ºã€‚

$x_1\gt x_2$ çš„æƒ…å†µå¯ä»¥å‘ç°å·¦ä¸Šç›´çº¿çš„ä¸ŠåŠéƒ¨åˆ†æ˜¯ä¸ä¼šç”¨äºæ§åˆ¶ç™½æ£‹çš„ï¼Œå› æ­¤ $(x_1,y_1)$ å¯ä»¥ç­‰æ•ˆæˆ $(x_2,y_1-x_1+x_2)$ï¼Œé€šè¿‡ç±»ä¼¼çš„åˆ†æå¯ä»¥è§„çº¦åˆ°ä¸Šé¢çš„å¼å­ã€‚

å› æ­¤ä»…éœ€åˆ¤æ–­æ˜¯å¦å­˜åœ¨è¿™æ ·ä¸€å¯¹æ£‹å­å³å¯ï¼Œå¯¹ max çš„å–å€¼è¿›è¡Œåˆ†ç±»è®¨è®ºï¼Œå¯ä»¥åœ¨ $O(n\log n)$ æ˜¯æ—¶é—´å†…è§£å†³ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e5+9;
const ll inf=1e18;

vector<int> A,B;
int x[N],y[N],p[N],n;
struct Fenwick{
	ll tr[N];
	inline void Init(){fill(tr+1,tr+n+1,-inf);}
	inline void Insert(int x,ll k){while(x<=n) tr[x]=max(tr[x],k),x+=x&-x;}
	inline ll Query(ll x){ll ans=-inf;while(x) ans=max(ans,tr[x]),x&=x-1;return ans;}
}P,R;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x[i]>>y[i];
		if(x[i]==y[i]){
			cout<<"Platina"<<endl;
			return 0;
		}else if(x[i]<y[i]){
			y[i]-=2;
			A.push_back(i);
		}else{
			x[i]-=2;
			B.push_back(i);
		}
	}

	vector<int> val(y+1,y+n+1);
	val.push_back(INT_MIN);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()),val.end());
	for(int i=1;i<=n;i++) p[i]=lower_bound(val.begin(),val.end(),y[i])-val.begin();
	sort(A.begin(),A.end(),[](int i,int j){return x[i]<x[j];});
	sort(B.begin(),B.end(),[](int i,int j){return x[i]<x[j];});

	ll ans=-inf;
	P.Init(),R.Init();
	for(int i=0,j=0;i<B.size();i++){
		while(j<A.size()&&x[A[j]]<x[B[i]]){
			P.Insert(p[A[j]],2*x[A[j]]);
			R.Insert(n-p[A[j]]+1,2*x[A[j]]-y[A[j]]);
			j++;
		}
		ans=max(ans,P.Query(p[B[i]]-1)+2*y[B[i]]-x[B[i]]-y[B[i]]);
		ans=max(ans,R.Query(n-p[B[i]]+1)+2*y[B[i]]-x[B[i]]);
	}
	P.Init(),R.Init();
	for(int i=0,j=0;i<A.size();i++){
		while(j<B.size()&&x[B[j]]<=x[A[i]]){
			P.Insert(p[B[j]],2*y[B[j]]);
			R.Insert(n-p[B[j]]+1,2*y[B[j]]-y[B[j]]);
			j++;
		}
		ans=max(ans,P.Query(p[A[i]]-1)+2*x[A[i]]-x[A[i]]-y[A[i]]);
		ans=max(ans,R.Query(n-p[A[i]]+1)+2*x[A[i]]-x[A[i]]);
	}

	cout<<(ans>=0?"Platina":"Yuto")<<endl;

	return 0;
}
```

### 22. Setting Maps

$k=1$ æ—¶å°±æ˜¯æœ€å°å‰²ï¼Œ$k\gt 1$ æ—¶è€ƒè™‘åˆ†å±‚å»ºç«‹æœ€å°å‰²æ¨¡å‹ï¼Œç†è®ºå¤æ‚åº¦ $O(nm^2k^3)$ï¼Œå®é™…è·‘çš„é£å¿«ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e2+9;
const int M=5e2+9;
const int K=5;
const int V=2*N*K;
const int E=2*(2*N+M)*K;
const int inf=INT_MAX;

vector<int> e[N];
int fi[V],ne[E],to[E],w[E],adj=1;
inline void AddEdge(int x,int y,int z){
	ne[++adj]=fi[x];
	fi[x]=adj;
	to[adj]=y;
	w[adj]=z;
}
inline void AddFlow(int x,int y,int z){
	AddEdge(x,y,z);
	AddEdge(y,x,0);
}

int cur[V],lev[V],s,t,n,m,k;
inline bool GetLevel(){
	for(int i=1;i<=2*n*k;i++) cur[i]=fi[i],lev[i]=0;
	lev[s]=1;
	queue<int> q;
	q.push(s);
	while(q.size()){
		int x=q.front();
		q.pop();
		if(x==t) return 1;
		for(int i=fi[x];i;i=ne[i]){
			int y=to[i];
			if(!w[i]) continue ;
			if(lev[y]) continue ;
			lev[y]=lev[x]+1;
			q.push(y);
		}
	}
	return 0;
}
inline int Work(int x,int k){
	if(x==t) return k;
	int rem=k;
	for(int &i=cur[x];i;i=ne[i]){
		int y=to[i];
		if(!w[i]) continue ;
		if(lev[y]!=lev[x]+1) continue ;
		int tmp=Work(y,min(rem,w[i]));
		w[i]-=tmp,w[i^1]+=tmp,rem-=tmp;
		if(!rem) return k;
	}
	return k-rem;
}
inline int MaxFlow(){
	int ans=0;
	while(GetLevel()) ans+=Work(s,inf);
	return ans;
}

vector<int> edge[N];
int c[N],dis[N],vis[N],st,ed;
inline int Id(int u,int k,int p){return u+(2*(k-1)+p)*n;}
inline void GetDis(){
	queue<int> q;
	q.push(st);
	dis[st]=1,vis[st]=1;
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int y:e[x]){
			if(vis[y]) continue ;
			vis[y]=1;
			dis[y]=dis[x]+1;
			q.push(y);
		}
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m>>k>>st>>ed;
	for(int i=1;i<=n;i++){
		cin>>c[i];
		for(int j=1;j<=k;j++){
			if(j+1<=k) AddFlow(Id(i,j,0),Id(i,j+1,1),inf);
			AddFlow(Id(i,j,0),Id(i,j,1),c[i]);
			edge[i].push_back(adj^1);
		}
	}
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		for(int j=1;j<=k;j++) AddFlow(Id(u,j,1),Id(v,j,0),inf);
		e[u].push_back(v);
	}
	s=Id(st,1,0),t=Id(ed,k,1);

	GetDis();
	if(!vis[ed]) cout<<0<<endl;
	else if(dis[ed]<k) cout<<-1<<endl;
	else{
		MaxFlow();
		vector<int> ans;
		for(int i=1;i<=n;i++){
			for(int j=1;j<=k;j++){
				if(lev[Id(i,j,0)]&&!lev[Id(i,j,1)]){
					ans.push_back(i);
					break ;
				}
			}
		}
		cout<<ans.size()<<endl;
		for(int x:ans) cout<<x<<' ';cout<<endl;
	}

	return 0;
}
```

### 23. How to Move the Beans

å“ˆå“ˆå“ˆæœ‰äººä¸ä¼šå‰ç¼€å’Œã€‚

é¦–å…ˆæƒ³åˆ° SG å‡½æ•°ï¼Œæœ´ç´ è½¬ç§»æ˜¯ 2D/1D çš„ã€‚

ç”±äºæ¯ä¸ªç‚¹è‡³å¤šåªæœ‰ 3 å‰ï¼Œå› æ­¤ SG å‡½æ•°çš„å€¼åŸŸæ˜¯ $[0,3]$ï¼Œè€ƒè™‘æš´åŠ›ç»´æŠ¤å‰ç¼€åç¼€å‡½æ•°å¤åˆï¼Œè½¬ç§»å˜ä¸º 2D/0Dã€‚

æ—¶é—´å¤æ‚åº¦ $O(n^2)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using Data=array<int,4>;
const int N=1e3+9;

char a[N][N];
int f[N][N],le[N],ri[N],n,m;
Data p[N][2],s[N][2];
inline int Mex(int x,int y){return __builtin_ctz(~(1<<x|1<<y));}
inline int Mex(int x,int y,int z){return __builtin_ctz(~(1<<x|1<<y|1<<z));}
inline Data Merge(Data x,Data y){
	Data z;
	for(int i:{0,1,2,3}) z[i]=y[x[i]];
	return z;
}
inline Data MexWith(int x){
	Data y;
	for(int i:{0,1,2,3}) y[i]=Mex(i,x);
	return y;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>a[i][j];
	}

	int ans=0;
	for(int j=1;j<=m;j++) f[n+1][j]=3;
	for(int i=n;i>=1;i--){
		p[0][0]=p[0][1]=s[m+1][0]=s[m+1][1]={0,1,2,3};
		for(int j=1;j<=m;j++){
			le[j]=le[j-1]|(a[i][j]=='#');
			p[j][0]=a[i][j]=='#'?Data({3,3,3,3}):Merge(p[j-1][0],MexWith(f[i+1][j]));
			p[j][1]=le[j]?p[j-1][1]:Merge(MexWith(f[i+1][j]),p[j-1][1]);
		}
		for(int j=m;j>=1;j--){
			ri[j]=ri[j+1]|(a[i][j]=='#');
			s[j][0]=a[i][j]=='#'?Data({3,3,3,3}):Merge(s[j+1][0],MexWith(f[i+1][j]));
			s[j][1]=ri[j]?s[j+1][1]:Merge(MexWith(f[i+1][j]),s[j+1][1]);
		}
		for(int j=1;j<=m;j++){
			f[i][j]=a[i][j]=='#'?3:Mex(f[i+1][j],
				le[j]?p[j-1][0][3]:p[j-1][0][s[j+1][1][3]],
				ri[j]?s[j+1][0][3]:s[j+1][0][p[j-1][1][3]]);
			if(a[i][j]=='B') ans^=f[i][j];
		}
	}

	cout<<(ans?"Alice":"Bob")<<endl;

	return 0;
}
```

### 24. Interesting Coloring

è€ƒè™‘æŠ½å‡º DFS ç”Ÿæˆæ ‘ï¼Œå°½é‡æ¯æ¡åˆ°æ ¹é“¾åªç”¨ $7$ ç§é¢œè‰²æŸ“è‰²ï¼Œç„¶åè®©éæ ‘è¾¹æˆä¸ºç¬¬ $8$ ç§é¢œè‰²ã€‚

è®¾ $f_{x,k}$ è¡¨ç¤º $x$ åˆ°æ ¹é“¾ä¸Šå…±æœ‰ $k$ ç§é¢œè‰²ï¼Œæ˜¯å¦å¯ä»¥æŸ“è‰²ä½¿å¾—å­æ ‘å†…æ¯æ¡åˆ°æ ¹é“¾åªç”¨ $7$ ç§é¢œè‰²æŸ“è‰²ï¼Œè¾¹ç•Œæ˜¯ $f_{x,8}=0$ã€‚

æœ‰è½¬ç§»ï¼š$\displaystyle f_{x,k}=[\sum_{y\in S_x} 1-f_{x,k+1}\leq k-1]$ï¼Œæ„ä¹‰å³ä¸ºå°½å¯èƒ½åœ°è®©èƒ½æ‰¿å—å¤šä¸€æ¡æ–°é¢œè‰²è¾¹çš„å¢åŠ æ–°é¢œè‰²ã€‚

ä»¤ $F(k)$ è¡¨ç¤ºä½¿ $f_{x,k}=0$ æœ€å°çš„ $siz_x$ï¼Œæœ‰è½¬ç§»ï¼š$F(k)=nF(k+1)+1,F(8)=1$ï¼Œå› æ­¤ $\displaystyle F(1)=\sum_{i=1}^7i!\gt 5555$ï¼Œå› æ­¤ä¸€å®šå¯ä»¥æŒ‰è¿™ç§æ–¹å¼æ„é€ å‡ºåˆæ³•è§£ï¼Œè¾“å‡ºæ–¹æ¡ˆæ˜¯ç®€å•çš„ã€‚

æ—¶é—´å¤æ‚åº¦åˆ†æå‡ºæ¥åº”è¯¥æ˜¯ $O(n\log n)$ çš„ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=6e3+9;
const int M=1e4+9;

vector<int> e[N],ans[M];
int u[M],v[M],c[M],id[N],fa[N],dep[N],vis[N],f[N][10],n,m;
inline void CalcF(int x){
	int p=8;
	vis[x]=1;
	f[x][8]=1;
	for(int i:e[x]){
		int y=x^u[i]^v[i];
		if(vis[y]) continue ;
		fa[y]=x;
		id[y]=i;
		dep[y]=dep[x]+1;
		CalcF(y);
		for(int j=1;j<8;j++){
			f[x][j]+=f[y][j+1];
			if(f[y][j]) p=min(p,j);
		}
	}
	for(int i=1;i<8;i++) f[x][i]=f[x][i]>=i;
	for(int i=p;i<8;i++) f[x][i]=1;
}
int tot;
inline void SetC(int x,int k,int o,vector<int> r){
	int p=-1;
	for(int i:e[x]){
		int y=x^u[i]^v[i];
		if(fa[y]!=x) continue ;
		if(!f[y][k+1]){
			c[i]=++tot;
			r.push_back(c[i]);
			SetC(y,k+1,c[i],r);
			r.pop_back();
		}else{
			p++;
			if(r[p]==o) p++;
			if(p>=k){
				cerr<<p<<' '<<k<<endl;
				for(int j=0;j<=8;j++) cerr<<f[x][j];cerr<<endl;
				for(int j:e[x]){
					int z=x^u[i]^v[i];
					if(fa[z]!=x) continue ;
					for(int k=0;k<=8;k++) cerr<<f[z][k];cerr<<endl;
				}
			}
			c[i]=r[p];
			SetC(y,k,c[i],r);
		}
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=m;i++){
		cin>>u[i]>>v[i];
		e[u[i]].push_back(i);
		e[v[i]].push_back(i);
	}

	CalcF(1);
	SetC(1,0,0,{});
	cerr<<tot<<endl;
	for(int i=1;i<=m;i++){
		if(c[i]) continue ;
		c[i]=++tot;
		vector<int> tmp;
		tmp.push_back(c[i]);
		int x=dep[u[i]]<dep[v[i]]?u[i]:v[i],y=x^u[i]^v[i],p=y;
		while(p!=x){
			tmp.push_back(c[id[p]]);
			p=fa[p];
		}
		sort(tmp.begin(),tmp.end());
		tmp.erase(unique(tmp.begin(),tmp.end()),tmp.end());
		ans[i]=tmp;
		p=y;
		while(p!=x){
			if(!ans[id[p]].size()) ans[id[p]]=tmp;
			p=fa[p];
		}
	}

	for(int i=1;i<=m;i++) cout<<c[i]<<' ';cout<<endl;
	for(int i=1;i<=m;i++){
		if(ans[i].size()>8){
			for(int x:ans[i]) cerr<<x<<' ';cerr<<endl;
		}
		cout<<ans[i].size()<<' ';
		for(int x:ans[i]) cout<<x<<' ';cout<<endl;
	}

	return 0;
}
```

### 27. AND Permutation

è¦æ·±åˆ»åæ€äº†ã€‚

è€ƒè™‘ä»ä½åˆ°é«˜å½’çº³æ„é€ ï¼Œå…ˆå°†åŸé›†åˆ $S$ æŒ‰å½“å‰ä½åˆ†æˆ $S_0$ å’Œ $S_1$ å¹¶æ¶ˆå»å½“å‰ä½ï¼Œé€’å½’ä¸‹å»æ„é€ ã€‚è¿˜åŸ $S_1$ æ—¶ä¼šå‡ºç°å½“å‰ä½å‡ä¸º $1$ è€Œé€ æˆæœ‰äº¤çš„æƒ…å†µï¼Œè€ƒè™‘åˆ° $S_1$ åœ¨ $S_0$ ä¸­ä¸€å®šæœ‰ä¸€ä¸ªå¯¹åº”çš„å€¼ï¼Œè¿˜åŸåäº¤æ¢åŒ¹é…å¯¹è±¡å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ï¼Œæ¯”è¾ƒæ‡’å†™äº† mapï¼Œæ—¶é—´å¤æ‚åº¦ $O(n\log^2 n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=(1<<18)+9;

int n;
ll a[N];
map<ll,ll> b;
inline void Construct(vector<ll> v,int d){
	if(d<0||!v.size()) return ;
	vector<ll> s[2];
	for(ll x:v) s[x>>d&1].push_back(x);
	Construct(s[0],d-1);
	Construct(s[1],d-1);
	for(ll x:s[1]){
		swap(b[x],b[x^(1ll<<d)]);
		b[x^(1ll<<d)]|=1ll<<d;
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],b[a[i]]=0;

	Construct(vector<ll>(a+1,a+n+1),60);

	for(int i=1;i<=n;i++) cout<<b[a[i]]<<endl;

	return 0;
}
```

### 31. Joke

é¦–å…ˆå¯¹ $p,q$ åš $p^{-1}$ çš„ç½®æ¢ä½¿å¾— $p=e$ï¼Œå…¶æ¬¡ä¸éš¾å¾—å‡º $s$ çš„å……è¦æ¡ä»¶æ˜¯ $\forall i<j,q_i>q_j,s_i=1\implies s_j=0$ã€‚

è€ƒå¯Ÿæœ€å¤§å€¼ï¼Œè®¾åºåˆ—ç”± $L,M,R$ ä¸‰éƒ¨åˆ†ç»„æˆï¼Œå…¶ä¸­ $M$ æ˜¯æœ€å¤§å€¼ï¼Œè®¾ $f(A)$ è¡¨ç¤ºåºåˆ— $A$ çš„ç­”æ¡ˆã€‚

é‚£ä¹ˆå¦‚æœæœ€å¤§å€¼å¡« $1$ï¼Œåé¢çš„éƒ½å¾—å¡« $0$ï¼Œå¦åˆ™æ— äº‹å‘ç”Ÿï¼Œå› æ­¤å¯ä»¥å¾—å‡º $f(LMR)=f(L)+f(LR)$ã€‚

è€Œ $q$ çš„ä¸Šå‡å­åºåˆ—ä¸ªæ•° $g(q)$ è½¬ç§»å¼ä¹Ÿæ°ä¸º $g(LMR)=g(L)+g(LR)$ã€‚

å› æ­¤ç­”æ¡ˆå°±æ˜¯ $q$ çš„ä¸Šå‡å­åºåˆ—ä¸ªæ•°ï¼Œè®¾ $f_{i,j,k}$ è¡¨ç¤ºè€ƒè™‘å‰ $i$ ä¸ªï¼Œé€‰äº† $j$ ä¸ª $q_i=0$ï¼Œç»“å°¾ä¸º $k$ çš„æ–¹æ¡ˆæ•°ï¼Œå‰ç¼€å’Œä¼˜åŒ– DP å¯ä»¥åšåˆ° $O(n^3)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e2+9;
const int mod=998244353;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int ans=1;
	while(y){
		if(y&1) MulAs(ans,x);
		MulAs(x,x);
		y>>=1;
	}
	return ans;
}
inline int Inv(int x){return QPow(x,mod-2);}

int fac[N],ifac[N];
inline void Init(int lim){
	fac[0]=1;
	for(int i=1;i<=lim;i++) fac[i]=Mul(fac[i-1],i);
	ifac[lim]=Inv(fac[lim]);
	for(int i=lim-1;~i;i--) ifac[i]=Mul(ifac[i+1],i+1);
}
inline int C(int n,int m){
	if(m<0||m>n) return 0;
	else return Mul(fac[n],Mul(fac[m],fac[n-m]));
}

int p[N],q[N],f[N][N][N],g[N],vis[N],n;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>p[i];
	for(int i=1;i<=n;i++) cin>>q[i];
	for(int i=1;i<=n;i++){
		while(p[i]!=i) swap(q[i],q[p[i]]),swap(p[i],p[p[i]]);
	}

	Init(n);
	f[0][0][0]=1;
	for(int i=1;i<=n;i++) if(q[i]) vis[q[i]]=1;
	for(int i=0;i<=n;i++){
		for(int j=0;j<=i;j++){
			for(int k=0;k<=n;k++){
				if(q[i+1]){
					AddAs(f[i+1][j][k],f[i][j][k]);
					if(q[i+1]>k) AddAs(f[i+1][j][q[i+1]],f[i][j][k]);
				}else{
					AddAs(f[i+1][j][k],f[i][j][k]);
					AddAs(g[k+1],f[i][j][k]);
				}
			}
			for(int k=0;k<=n;k++){
				if(k+1<=n) AddAs(g[k+1],g[k]);
				if(!vis[k]) AddAs(f[i+1][j+1][k],g[k]);
				g[k]=0;
			}
		}
	}

	int m=n-accumulate(vis+1,vis+n+1,0),ans=0;
	for(int j=0;j<=n;j++){
		for(int k=0;k<=n;k++) AddAs(ans,Mul(f[n][j][k],fac[m-j]));
	}

	cout<<ans<<endl;

	return 0;
}
```

### 36. Nein

é¦–å…ˆç›´æ¥è®¡ç®—ç­”æ¡ˆçœ‹èµ·æ¥ä¸æ˜¯å¾ˆå¥½åšï¼Œè€ƒè™‘æ±‚è§£ç¬¬ $n$ å¤§çš„ä¸åŒ…å« $9$ çš„ $10^k-1$ çš„å€æ•°ã€‚

ç”±äº $10^k-1$ æœ‰å¾ªç¯æº¢å‡ºçš„æ€§è´¨ï¼Œæ‰€ä»¥ $10^k-1$ çš„å€æ•°æŒ‰æ¯ $k$ ä¸ªæ•°åˆ†ä¸€æ®µåŠ èµ·æ¥çš„å’Œä¸€å®šä¹Ÿæ˜¯ $10^k-1$ çš„å€æ•°ï¼Œè€Œä¸”å‡è®¾å…±æœ‰ $B$ æ®µï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°ä½å’Œä¸€å®šä¸ä¼šå¤§äº $B(10^k-1)$ã€‚

è€ƒè™‘ä»é«˜åˆ°ä½ä¾æ¬¡ç¡®å®šç­”æ¡ˆæ¯ä¸€ä½ï¼Œé‚£ä¹ˆéœ€è¦è®¡ç®—ç¡®å®šä¸€ä¸ªå‰ç¼€ä¹‹åçš„åˆæ³•æ–¹æ¡ˆæ•°ã€‚ä»¤å‰é¢å·²ç»å¡«å‡ºæ¥çš„æ•°ä½å’Œæ˜¯ $-r\pmod{10^k-1}$ï¼Œåˆ™åé¢å¡«å‡ºæ¥çš„æ•°ä½å’Œå°±æ˜¯ $r+t(10^k-1)$ï¼Œå…¶ä¸­ $t\in[0,B]$ã€‚å› ä¸º $t$ å¾ˆå°ï¼Œæ‰€ä»¥ç›´æ¥æšä¸¾ $r+t(10^k-1)$ æ˜¯ä»€ä¹ˆï¼Œç„¶åå°±å¯ä»¥ç›´æ¥æ•°ä½ DPã€‚å…·ä½“åœ°ï¼Œè®¾ $g_{i,j}$ è¡¨ç¤ºç›®å‰å¡«åˆ°æ•°ä½å’Œçš„ç¬¬ $i$ ä½ï¼Œå¹¶ä»ä¸‹é¢æ¥å—äº† $j$ æ¬¡è¿›ä½çš„æ–¹æ¡ˆæ•°ã€‚é‚£ä¹ˆæœ‰è½¬ç§» $\displaystyle g_{i,j}=\sum_{k=0}^B g_{i-1,k}f_{c_{i-1},10j+s_{i-1}-k}$ï¼Œå…¶ä¸­ $\displaystyle f_{i,j}=(\sum_{t=0}^8x^t)^i[x^j]$ï¼Œ$c_i$ è¡¨ç¤ºåç¼€ä¸­ä¸‹æ ‡æ¨¡ $k$ ä¸ $i$ åŒä½™çš„ä½çš„ä¸ªæ•°ï¼Œ$s_i$ åˆ™æ˜¯ $r+t(10^k-1)$ çš„ç¬¬ $i$ ä½ï¼Œæ–¹æ¡ˆæ•°å³ä¸º $\displaystyle g_{k,\lfloor \frac {r+t(10^k-1)}{10^k}\rfloor}$ã€‚

æ—¶é—´å¤æ‚åº¦ $O(9kT^4)$ï¼Œå…¶ä¸­ $T=37$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll=long long;
using bint=__int128;

const int D=4e2;
const bint T=1e18;

ll k,n;
bint f[D][D<<3],g[D][D],p10[D];
inline bint Count(int t,bint lft,vector<int> &cnt){
	if(!t) return !lft;
	vector<int> trg(k+1);
	for(int i=0;i<k;i++) trg[i]=lft%10,lft/=10;
	g[0][0]=1;
	for(int i=0;i<k;i++){
		for(int p=0;p<=t;p++){
			for(int q=0;q<=t;q++){
				if(p*10+trg[i]-q>=0) g[i+1][p]+=g[i][q]*f[cnt[i]][p*10+trg[i]-q];	
			}
		}
	}
	bint ans=g[k][lft];
	for(int i=0;i<=k;i++){
		for(int p=0;p<=t;p++) g[i][p]=0;
	}
	return ans;
}

signed main(){
	cin>>k>>n;

	f[0][0]=1,p10[0]=1;
	for(int i=1;i<=37;i++){
		for(int j=0;j<=i*8;j++){
			for(int k=j;k>=max(j-8,0);k--) f[i][j]+=f[i-1][k];
		}
	}
	for(int i=1;i<=37;i++) p10[i]=p10[i-1]*10;

	bint ans=0,s9=0;
	for(int i=0;i<k;i++) s9=s9*10+9;
	for(int i=37;~i;i--){
		int t=(i+k-1)/k;
		vector<int> cnt(k,0);
		for(int j=0;j<i;j++) cnt[j%k]++;
		for(int x=0;x<9;x++){
			bint sum=-!ans;
			for(int c=0;c<=t;c++){
				bint lft=c*s9+(s9-ans%s9)%s9;
				sum+=Count(t,lft,cnt);
			}
			if(n<=sum) break ;
			n-=sum,ans+=p10[i];
		}
	}

	ans/=s9;

	if(ans<T) cout<<ll(ans)<<endl;
	else cout<<ll(ans/T)<<setw(18)<<setfill('0')<<ll(ans%T)<<endl;

	return 0;
}
```

### 41. Link Cut Digraph

ç»å…¸æ°¸æµä¼ ã€‚

è€ƒè™‘æ•´ä½“äºŒåˆ†ç¬¬ $i$ æ¡è¾¹èƒ½å¤ŸåŠ å…¥åˆ°æŸä¸ª SCC çš„æ—¶é—´ $t_i$ï¼ŒåŸå…ˆå…¨éƒ¨æš‚å®š $t_i=i$ã€‚é‚£ä¹ˆäºŒåˆ† $[l,r]$ çš„æ—¶å€™ï¼Œ$t_i\in(r,+\infty]$ çš„è¾¹è‚¯å®šä¸ä¼šèµ·åˆ°ä»»ä½•ä½œç”¨ï¼Œè€Œ $[1,l)$ çš„è¾¹åˆ™å·²ç»è¢«ç¼©å®Œäº†ï¼Œäºæ˜¯å¯ä»¥è¢«è¡¨è¾¾æˆ SCC å†…éƒ¨çš„è¾¹ï¼Œå³ç¼©å®Œç‚¹ä¹‹åå…¨éƒ¨åœ¨ SCC å†…éƒ¨ï¼Œä¹Ÿä¸ä¼šèµ·åˆ°ä½œç”¨ã€‚å› æ­¤äºŒåˆ†æ—¶ä»…éœ€åŠ å…¥ $t_i\in[l,mid]$ çš„è¾¹ï¼Œè‹¥æŸæ¡è¾¹æ²¡èƒ½æˆåŠŸåŠ å…¥ä¸€ä¸ª SCCï¼Œåˆ™ $t_i\leftarrow mid+1$ã€‚ç»§ç»­æ•´ä½“äºŒåˆ†å³å¯ã€‚åœ¨è·‘å³è¾¹ä¹‹å‰éœ€è¦æŠŠåŒå±ä¸€ä¸ª SCC çš„ç‚¹ç¼©åœ¨ä¸€èµ·ï¼Œé¡ºå¸¦ç»´æŠ¤ä¸€ä¸‹ SCC å¤§å°ã€‚

æ—¶é—´å¤æ‚åº¦ $O(m\log m)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e5+9;

ll ans[N];
int ep[N],eq[N],t[N],n,m;

ll cur;
int fa[N],siz[N];
inline int Find(int x){return x==fa[x]?x:fa[x]=Find(fa[x]);}
inline void Merge(int x,int y){
	x=Find(x),y=Find(y);
	if(x==y) return ;
	if(siz[x]<siz[y]) swap(x,y);
	cur-=1ll*siz[x]*(siz[x]-1)/2;
	cur-=1ll*siz[y]*(siz[y]-1)/2;
	fa[y]=x;
	siz[x]+=siz[y];
	cur+=1ll*siz[x]*(siz[x]-1)/2;
}

vector<int> e[N],stk;
int dfn[N],low[N],ins[N],bel[N],dcnt;
inline void Tarjan(int x){
	ins[x]=1,stk.push_back(x);
	dfn[x]=low[x]=++dcnt;
	for(int y:e[x]){
		if(!dfn[y]){
			Tarjan(y);
			low[x]=min(low[x],low[y]);
		}else if(ins[y]) low[x]=min(low[x],dfn[y]);
	}
	if(low[x]==dfn[x]){
		while(stk.size()){
			int p=stk.back();
			stk.pop_back();
			ins[p]=0;
			bel[p]=x;
			if(p==x) break ;
		}
	}
}
inline void BinSch(int l,int r,vector<int> &v){
	int mid=l+r>>1;
	vector<int> node;
	for(int i:v){
		if(t[i]>mid) continue ;
		e[Find(ep[i])].push_back(Find(eq[i]));
		node.push_back(Find(ep[i]));
		node.push_back(Find(eq[i]));
	}

	for(int x:node) if(!dfn[x]) Tarjan(x);
	auto Clear=[&](){
		for(int x:node){
			dfn[x]=low[x]=ins[x]=bel[x]=0;
			e[x].clear();
		}
		dcnt=0;
	};

	if(l==r){
		for(int x:node) Merge(x,bel[x]);
		ans[l]=cur;
		Clear();
	}else{
		vector<int> lv,rv;
		for(int i:v){
			if(t[i]>mid) rv.push_back(i);
			else{
				if(bel[Find(ep[i])]==bel[Find(eq[i])]) lv.push_back(i);
				else t[i]=mid+1,rv.push_back(i);
			}
		}
		Clear();
		BinSch(l,mid,lv);
		BinSch(mid+1,r,rv);
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=m;i++) cin>>ep[i]>>eq[i];

	for(int i=1;i<=n;i++) fa[i]=i,siz[i]=1;
	for(int i=1;i<=m;i++) t[i]=i;
	vector<int> v(m);
	iota(v.begin(),v.end(),1);

	BinSch(1,m,v);

	for(int i=1;i<=m;i++) cout<<ans[i]<<endl;

	return 0;
}
```

### 44. AND PLUS OR

ä¸æ˜¯æˆ‘è·Ÿä½ ä»¬è¿™ç¾¤é«˜æ™ºå•†äººç¾¤æ‹¼äº†ã€‚

è€ƒè™‘æŠŠç­”æ¡ˆçš„ $S$ å’Œ $T$ è°ƒæ•´æˆæ¯”è¾ƒå¥½çœ‹çš„å½¢å¼ã€‚

> **ç»“è®º**ï¼šå¦‚æœ $A$ æœ‰è§£ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨ä¸€ç»„ $S,T$ ä½¿å¾— $(S,T)$ æ˜¯åˆæ³•ç­”æ¡ˆä¸” $|S\oplus T|=2$ã€‚
>
> **è¯æ˜**ï¼š
>
> æ˜¾ç„¶ $|S\oplus T|\lt 2$ è‚¯å®šä¸åˆæ³•ã€‚
>
> è®¾ $(S_0,T_0)$ ä¸º $A$ çš„ä¸€ç»„ $|S_0\oplus T_0|$ æœ€å°çš„è§£ï¼Œå¹¶å‡è®¾ $|S\setminus T|<|T\setminus S|\neq 1$ã€‚
>
> ä»¤ $P=S\cap T,Q=S\setminus T,R=T\setminus S,x\in R,R'=R/\{x\}$ã€‚
>
> é‚£ä¹ˆ $(P\cup Q\cup R',P \cup R' \cup \{x\})$ å’Œ $(P\cup Q,P \cup R')$ ä¸åˆæ³•ï¼Œä½† $(P\cup Q,P\cup R'\cup \{x\})$ åˆæ³•ï¼Œå³ï¼š
>
> - $A(P\cup Q)+A(P\cup R'\cup \{x\}) \lt A(P)+A(P\cup Q\cup R'\cup \{x\})$ã€‚
> - $A(P\cup Q\cup R')+A(P \cup R' \cup \{x\}) \geq A(P\cup R')+A(P\cup Q\cup R'\cup \{x\})$ã€‚
> - $A(P\cup Q)+A(P \cup R')\geq A(P)+A(P\cup Q\cup R')$ã€‚
>
> å®¹æ˜“å‘ç°äºŒå¼åŠ ä¸‰å¼ä¸ä¸€å¼çŸ›ç›¾ã€‚
>
> å› æ­¤å¯ä»¥è¯´æ˜ $(P\cup Q\cup R',P \cup R' \cup \{x\})$ å’Œ $(P\cup Q,P \cup R')$ è‡³å°‘æœ‰ä¸€ç»„åˆæ³•ï¼Œä»è€Œå¯ä»¥ä¸æ–­æŠŠ $|T\setminus S|$ è°ƒæ•´åˆ° $1$ã€‚
>
> å¯¹ $|S\setminus T|$ åšåŒæ ·çš„æ“ä½œå³å¯ä»¤ $|S\oplus T|=|S\setminus T|+|T\setminus S|=2$ã€‚

$|S\oplus T|=2$ çš„ $(S,T)$ åªæœ‰ $O(n^22^n)$ å¯¹ï¼Œæšä¸¾æ‰¾å‡ºç­”æ¡ˆå³å¯ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=(1<<20)+9;

int a[N],n;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=0;i<(1<<n);i++) cin>>a[i];

	for(int sta=0;sta<(1<<n);sta++){
		for(int i=0;i<n;i++){
			for(int j=i+1;j<n;j++){
				int tta=sta^(1<<i)^(1<<j);
				if(a[sta]+a[tta]<a[sta&tta]+a[sta|tta]){
					cout<<sta<<' '<<tta<<endl;
					return 0;
				}
			}
		}
	}

	cout<<-1<<endl;

	return 0;
}
```

### *52. Angle Beats 2.0

### 53. Good Coloring

ç»™æ¯æ¡è¾¹æŒ‰é¢œè‰²å¤§å°ä»å°åˆ°å¤§å®šå‘ï¼Œè·‘æœ€é•¿è·¯ï¼ŒæŒ‰æœ€é•¿è·¯æŸ“è‰²å³å¯ã€‚

è¯æ˜æ˜¾ç„¶ï¼Œæœ€é•¿è·¯æ˜¾ç„¶ä¸ä¼šå¤§äº $k$ï¼Œå¦‚æœä¸¤ä¸ªç›¸é‚»çš„ç‚¹ç›¸åŒæ˜¾ç„¶ä¸æ˜¯æœ€é•¿è·¯ã€‚

ç”±äºæ˜¯ DAG å¯ä»¥ç›´æ¥æ‹“æ‰‘æ’åºï¼Œæ—¶é—´å¤æ‚åº¦ $O(n+m)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=6e5+9;

int c[N],n,m,k;
vector<int> e[N];

int dis[N],pre[N],in[N];
inline void LPFA(){
	queue<int> q;
	for(int i=1;i<=n;i++){
		dis[i]=pre[i]=0;
		if(!in[i]) q.push(i);
	}
	while(q.size()){
		int x=q.front();
		q.pop();
		for(int y:e[x]){
			if(dis[x]+1>dis[y]){
				pre[y]=x;
				dis[y]=dis[x]+1;
			}
			if(!--in[y]) q.push(y);
		}
	}
}
inline void Solve(){
	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>c[i];
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		if(c[u]>c[v]) e[u].push_back(v),in[v]++;
		else e[v].push_back(u),in[u]++;
	}

	LPFA();

	int p=max_element(dis+1,dis+n+1)-dis;
	cout<<dis[p]+1<<' ';
	for(int i=1;i<=n;i++) cout<<dis[i]+1<<' ';cout<<endl;
	while(p) cout<<p<<' ',p=pre[p];cout<<endl;

	for(int i=1;i<=n;i++) e[i].clear();
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);
	
	int T;
	cin>>T;
	while(T--) Solve();
	
	return 0;
}
```

### 61. Easy Problem

å‘ƒå‘ƒå‘ƒå•Šå•Šå•Šã€‚

é¦–å…ˆè€ƒè™‘ Hall å®šç†ï¼Œç„¶åè¿™ä¸ªä¸œè¥¿æ€ä¹ˆå°±å˜æˆçŸ©å½¢åŠ å…¨å±€ max äº†ï¼Œæˆ‘å’‹ä¸ä¼šã€‚

è®¾å½“å‰å–åˆ°çš„ä½ç½®æ˜¯ $x$ï¼Œå‘ç°æ‰€æœ‰åŒºé—´å…¨éƒ¨äº¤äº $x$ å¤„ï¼Œæ‰€ä»¥è€ƒè™‘åˆ†æˆå·¦åŠå³åŠåˆ»ç”»ã€‚

å¯¹äºæ§½ $(l_i,r_i,c_i)$ ï¼Œå°†å…¶é¢åº¦æŒ‰ $\lt x$ å’Œ $\geq x$ åˆ†æˆ $L_i,R_i$ï¼Œæœ‰ $L_i+R_i=c_i$ã€‚$x$ ä»å·¦å‘å³æ‰«æ—¶ï¼Œ$L_i$ ä¸€å®šé€’å¢ï¼ŒåŸå› æ˜¾ç„¶ã€‚

æ ¹æ® Hall å®šç†ï¼Œå¯ä»¥å¾—å‡ºç­”æ¡ˆå°±æ˜¯ $\displaystyle \min_{p\leq x} (\sum_{i=p}^{x-1} a_i+\sum_{l_i\lt p} L_i)+\min_{p\geq x-1} (\sum_{i=x}^p a_i+\sum_{r_i\gt p} R_i)$ï¼Œè€ƒè™‘è´ªå¿ƒåœ°è°ƒæ•´ $L_i,R_i$ï¼Œæ¯æ¬¡æ‰¾åˆ° $_i$ æœ€å°ä¸”ä¸ä¼šå½±å“åˆ°å³ä¾§å–å€¼çš„ $i$ è°ƒæ•´å…¶ $L_i,R_i$ã€‚ç”±äºè¿™æ˜¯åŒ¹é…ï¼Œå› æ­¤å¦‚æœå³ä¾§å¯ä»¥å–åˆ°æŸä¸ªä¸Šç•Œåˆ™ä¸€å®šå­˜åœ¨æœ€ä¼˜æ–¹æ¡ˆä½¿å¾—å³ä¾§å–åˆ°ä¸Šç•Œã€‚è°ƒæ•´æ¯æ¬¡è¦ä¹ˆå°† $R_i$ ç½®ä¸º $0$ï¼Œè¦ä¹ˆå°†å³ä¾§æœ€å°å€¼å‘å·¦ç§»ï¼Œè®¾åŠ¿èƒ½ä¸ºçº¿æ®µæ ‘ä¸Šå·¦å„¿å­æœ€å°å€¼å¤§äºå³å„¿å­æœ€å°å€¼çš„èŠ‚ç‚¹æ•°ï¼Œæ¯æ¬¡çº¿æ®µæ ‘æ“ä½œè‡³å¤šå¢åŠ  $O(\log n)$ çš„æ˜¯èƒ½ï¼Œæœ€å°å€¼å·¦ç§»å‡å°‘è‡³å°‘ $1$ çš„åŠ¿èƒ½ï¼Œæ€»å¤æ‚åº¦ $O(n\log ^2 n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e5+9;
const int inf=1e9+7;

struct RARMQ{
	struct Node{
		int l,r;
		ll tag;
		pair<ll,int> dat;
	}tr[N<<2];

	inline void PushUp(int x){tr[x].dat=min(tr[x<<1].dat,tr[x<<1|1].dat);}
	inline void Push(int x,ll k){tr[x].dat.first+=k,tr[x].tag+=k;}
	inline void PushDown(int x){
		if(tr[x].tag){
			Push(x<<1,tr[x].tag);
			Push(x<<1|1,tr[x].tag);
			tr[x].tag=0;
		}
	}
	
	inline void Build(int x,int l,int r){
		tr[x].l=l,tr[x].r=r,tr[x].tag=0;
		if(tr[x].l==tr[x].r) return tr[x].dat={0,l},void();
		int mid=l+r>>1;
		Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
		PushUp(x);
	}
	inline void Modify(int x,int l,int r,ll k){
		if(l>r) return ;
		if(l<=tr[x].l&&tr[x].r<=r) return Push(x,k);
		PushDown(x);
		int mid=tr[x].l+tr[x].r>>1;
		if(l<=mid) Modify(x<<1,l,r,k);
		if(r>mid) Modify(x<<1|1,l,r,k);
		PushUp(x);
	}
	inline pair<ll,int> Query(int x,int l,int r){
		if(l>r) return {inf,0};
		if(l<=tr[x].l&&tr[x].r<=r) return tr[x].dat;
		PushDown(x);
		int mid=tr[x].l+tr[x].r>>1;
		if(r<=mid) return Query(x<<1,l,r);
		else if(l>mid) return Query(x<<1|1,l,r);
		else return min(Query(x<<1,l,r),Query(x<<1|1,l,r));
	}
}L,R;
struct PSRMQ{
	struct DelHeap{
		priority_queue<array<int,2>> p,q;
		inline void Insert(array<int,2> x){p.push(x);}
		inline void Erase(array<int,2> x){q.push(x);}
		inline array<int,2> Top(){
			while(q.size()&&p.top()==q.top()) p.pop(),q.pop();
			return p.top();
		}
		inline void Clear(){
			while(p.size()) p.pop();
			while(q.size()) q.pop();
		}
	}h[N];
	struct Node{
		int l,r;
		array<int,2> dat;
	}tr[N<<2];
	inline void PushUp(int x){tr[x].dat=min(tr[x<<1].dat,tr[x<<1|1].dat);}
	inline void Build(int x,int l,int r){
		tr[x].l=l,tr[x].r=r;
		if(tr[x].l==tr[x].r){
			h[l].Clear();
			h[l].Insert({-inf,0});
			tr[x].dat={inf,0};
			return ;
		}
		int mid=l+r>>1;
		Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
		PushUp(x);
	}
	inline void Update(int x,int pos){
		if(tr[x].l==tr[x].r){
			tr[x].dat={-h[pos].Top()[0],h[pos].Top()[1]};
			return ;
		}
		int mid=tr[x].l+tr[x].r>>1;
		if(pos<=mid) Update(x<<1,pos);
		else Update(x<<1|1,pos);
		PushUp(x);
	}
	inline array<int,2> Query(int x,int l,int r){
		if(l<=tr[x].l&&tr[x].r<=r) return tr[x].dat;
		int mid=tr[x].l+tr[x].r>>1;
		if(r<=mid) return Query(x<<1,l,r);
		else if(l>mid) return Query(x<<1|1,l,r);
		else return min(Query(x<<1,l,r),Query(x<<1|1,l,r));
	}
}P;

ll ans[N];
vector<int> st[N],ed[N];
int a[N],l[N],r[N],c[N],lc[N],rc[N],n,m;
inline void Solve(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=m;i++){
		cin>>l[i]>>r[i]>>c[i];
		if(!c[i]) continue ;
		st[l[i]].push_back(i);
		ed[r[i]].push_back(i);
	}

	L.Build(1,0,n+1),R.Build(1,0,n+1),P.Build(1,0,n+1);
	for(int i=1;i<=n;i++) R.Modify(1,i,n,a[i]);
	for(int x=1;x<=n;x++){
		for(int i:st[x]){
			lc[i]=0,rc[i]=c[i];
			P.h[r[i]].Insert({-l[i],i});
			P.Update(1,r[i]);
			R.Modify(1,0,r[i]-1,c[i]);
		}
		while(true){
			auto p=R.Query(1,x-1,n);
			auto q=P.Query(1,x-1,p.second);
			if(!q[1]) break ;
			int i=q[1];
			ll tmp=min(ll(rc[i]),R.Query(1,x-1,r[i]-1).first-p.first);
			lc[i]+=tmp,rc[i]-=tmp;
			L.Modify(1,l[i]+1,n+1,tmp);
			R.Modify(1,0,r[i]-1,-tmp);
			if(!rc[i]){
				P.h[r[i]].Erase({-l[i],i});
				P.Update(1,r[i]);
			}
		}
		ans[x]=L.Query(1,1,x).first+R.Query(1,x-1,n).first;
		for(int i:ed[x]){
			if(rc[i]){
				P.h[r[i]].Erase({-l[i],i});
				P.Update(1,r[i]);
			}
			L.Modify(1,l[i]+1,n+1,-lc[i]);
			R.Modify(1,0,r[i]-1,-rc[i]);
		}
		R.Modify(1,x,n,-a[x]);
		L.Modify(1,1,x,a[x]);
	}

	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';cout<<endl;

	for(int i=1;i<=n;i++){
		st[i].clear();
		ed[i].clear();
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 65. Building Bombing

$L$ ä¹‹å‰çš„ç‚¹æ²¡å•¥ç”¨ï¼Œå¯¹äº $L$ åé¢çš„ç‚¹è®¾ $f_{i,j}$ è¡¨ç¤ºä½¿ $i$ æˆä¸º $L$ åé¢ç¬¬ $j$ å°çš„è¦æ“ä½œå‡ æ¬¡ï¼Œæœ‰è½¬ç§»ï¼š

-   $\displaystyle f_{i,j}=\min_{L\leq p<i} (f_{p,j-1}+\sum_{q=p+1}^i[h_q>h_p])$ã€‚

è¿™æ˜¾ç„¶æ˜¯æ–¹ä¾¿ç”¨åŒºé—´åŠ åŒºé—´æœ€å°å€¼å€¼åŸŸçº¿æ®µæ ‘ç»´æŠ¤çš„ï¼Œæ—¶é—´å¤æ‚åº¦ $O(nk\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=1e5+9;
const int inf=1e9+7;

struct Node{
	int l,r,dat,tag;
}tr[N<<2];

inline void PushUp(int x){tr[x].dat=min(tr[x<<1].dat,tr[x<<1|1].dat);}
inline void Push(int x,int k){tr[x].dat+=k,tr[x].tag+=k;}
inline void PushDown(int x){
	if(tr[x].tag){
		Push(x<<1,tr[x].tag);
		Push(x<<1|1,tr[x].tag);
		tr[x].tag=0;
	}
}
inline void Build(int x,int l,int r){
	tr[x].l=l,tr[x].r=r,tr[x].tag=0;
	if(tr[x].l==tr[x].r) return tr[x].dat=inf,void();
	int mid=tr[x].l+tr[x].r>>1;
	Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
	PushUp(x);
}
inline void Set(int x,int pos,int k){
	if(tr[x].l==tr[x].r) return tr[x].dat=min(tr[x].dat,k),void();
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1;
	if(pos<=mid) Set(x<<1,pos,k);
	else Set(x<<1|1,pos,k);
	PushUp(x);
}
inline void Modify(int x,int l,int r,int k){
	if(l>r) return ;
	if(l<=tr[x].l&&tr[x].r<=r) return Push(x,k);
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1;
	if(l<=mid) Modify(x<<1,l,r,k);
	if(r>mid) Modify(x<<1|1,l,r,k);
	PushUp(x);
}
inline int Query(int x,int l,int r){
	if(l>r) return inf;
	if(l<=tr[x].l&&tr[x].r<=r) return tr[x].dat;
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1,ans=inf;
	if(l<=mid) ans=min(ans,Query(x<<1,l,r));
	if(r>mid) ans=min(ans,Query(x<<1|1,l,r));
	return ans;
}

int a[N],f[N],n,p,k;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>p>>k;
	for(int i=1;i<=n;i++) cin>>a[i];
	a[++n]=inf;

	int ans=0;
	for(int i=1;i<p;i++) if(a[i]>=a[p]) ans++;
	
	vector<int> val(a,a+n+1);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()));
	for(int i=1;i<=n;i++) a[i]=lower_bound(val.begin(),val.end(),a[i])-val.begin();

	f[p]=0;
	for(int i=p+1;i<=n;i++) f[i]=inf;
	for(int o=1;o<=k;o++){
		Build(1,1,n);
		for(int i=p;i<=n;i++){
			int tmp=f[i];
			f[i]=Query(1,1,a[i]-1);
			Modify(1,1,a[i]-1,1);
			Set(1,a[i],tmp);
		}
	}
	ans+=f[n];
	
	cout<<(ans<inf/2?ans:-1)<<endl;

	return 0;
}
```

### 66. Routes

æˆ‘æ“æˆ‘æ€ä¹ˆèŠ±äº†æ•´æ•´ä¸¤å¤©æ—¶é—´æ„è¯†åˆ°è‡ªå·±æ˜¯ä¸ªå‚»é€¼ã€‚

ä»¥ä¸‹è§„å®š $d(u,v),f(p,q),g(u,p)$ åˆ†åˆ«è¡¨ç¤ºç‚¹ $u$ åˆ°ç‚¹ $v$ï¼Œé¢œè‰² $p$ åˆ°é¢œè‰² $q$ï¼Œç‚¹ $u$ åˆ°é¢œè‰² $p$ çš„æœ€çŸ­è·¯ï¼Œ$c_u$ è¡¨ç¤ºç‚¹ $u$ çš„é¢œè‰²ã€‚

é¦–å…ˆæ˜¾ç„¶æœ‰ $f(c_u,p)\leq g(u,p)\leq f(c_u,p)+1$ï¼Œä»è€Œæœ‰ $f(c_u,c_v)\leq d(u,v)\leq f(c_u,c_v)+2$ã€‚

å…ˆå‡è®¾æ‰€æœ‰ç‚¹å¯¹éƒ½ç»è¿‡é£æœºè½¬ç§»è¿‡ä¹‹ä¸Šä¸€æ¬¡ï¼Œåé¢å¯ä»¥å†èŠ± $O(nk)$ çš„æ—¶é—´ä¿®æ­£ï¼Œå› ä¸ºå•ç»„ç­”æ¡ˆæ˜¾ç„¶å­˜åœ¨ä¸Šç•Œ $2k-1$ã€‚

è€ƒè™‘æšä¸¾ $u\rightarrow v$ ä¸­ç»è¿‡çš„ä¸­è½¬é¢œè‰²ï¼Œå³æœ‰ $\displaystyle d(u,v)=\min_p g(u,p)+g(v,p)+1=0/1/2+\min_pf(c_u,p)+f(p,c_v)+1$ã€‚

ç”±äºé¢œè‰²æ•°æ˜¯æå°‘çš„ï¼Œè€ƒè™‘æšä¸¾ $c_u,c_v$ï¼Œå¯¹ $d(u,v)=0/1/2+f(c_u,c_v)$ åˆ†åˆ«è®¡æ•°ã€‚

è®¾æ©ç  $\displaystyle s_u=\{p|g(u,p)=f(c_u,p)\},m_\Delta=\{p|f(c_u,p)+f(p,c_v)+\Delta=f(c_v,c_v)\}$ï¼š

- é‚£ä¹ˆ $d(u,v)=f(c_u,c_v)$ çš„æ¡ä»¶å°±æ˜¯ $\displaystyle s_u \cap s_v\cap m_0\neq \varnothing$ã€‚è€ƒè™‘æšä¸¾ $c_u$ å’Œ $v$ï¼Œä»¥åŠé¢„å¤„ç†å‡º $s_u$ çš„é«˜ç»´å‰ç¼€å’Œï¼Œåˆ™æ»¡è¶³æ¡ä»¶çš„ $(u,v)$ å¯¹æ•°æ€»ä½“å¯ä»¥åœ¨ $O(k^22^k+nk)$ çš„æ—¶é—´è®¡ç®—ã€‚
- ç±»ä¼¼åœ° $d(u,v)=f(c_u,c_v)+1$ çš„æ¡ä»¶ç­‰ä»·äº $\displaystyle (s_u \oplus s_v)\cap m_0\neq \varnothing$ æˆ– $\displaystyle s_u \cap s_v\cap m_1\neq \varnothing$ã€‚è¿™ä¸ªä¸æ˜¯å¾ˆå¥½æ±‚ï¼Œè€ƒè™‘ä» $d(u,v)=f(c_u,c_v)+0/2$ å®¹æ–¥å¾—å‡ºã€‚
- è€Œ $d(u,v)=f(c_u,c_v)+2$ çš„æ¡ä»¶æ˜¯ $\displaystyle (s_u \cup s_v)\cap m_0 = \varnothing$ ä¸” $\displaystyle s_u \cap s_v\cap m_1 = \varnothing$ã€‚è¿™ä¸ªå¯ä»¥å’Œ $d(u,v)=f(c_u,c_v)$ ç±»ä¼¼çš„é€šè¿‡ä½è¿ç®—æŠ€å·§åœ¨ç›¸åŒçš„æ—¶é—´å¤æ‚åº¦å†…è®¡ç®—å¾—åˆ°ã€‚

æ—¶é—´å¤æ‚åº¦ $O(k^3+nk+k^22^k)$ï¼Œä»£ç çœ‹èµ·æ¥å› ä¸ºå†…å­˜è®¿é—®çš„åŸå› å¸¸æ•°å¾ˆå¤§ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e6+9;
const int K=2e1+9;
const int S=(1<<16)+9;
const int inf=1e9+7;

string s[N];
int st[N],n,m,k;

vector<int> p[K];
vector<array<int,2>> e[N+K];
int bel[N],d[K][N+K],c[K][K],v[K][S],sta[N],m1[K][K],m2[K][K];
inline void BFS(int s,int *dis){
	deque<int> q;
	vector<int> vis(n+k+1,0);
	for(int i=1;i<=n+k;i++) dis[i]=inf;
	dis[s]=0;
	q.push_back(s);
	while(q.size()){
		int x=q.front();
		q.pop_front();
		if(vis[x]) continue ;
		vis[x]=1;
		for(auto p:e[x]){
			if(dis[x]+p[1]<dis[p[0]]){
				dis[p[0]]=dis[x]+p[1];
				if(!p[1]) q.push_front(p[0]);
				else q.push_back(p[0]);
			}
		}
	}
}
inline int Dist(int x,int y){
	if(bel[x]==bel[y]) return x!=y;
	if(bel[x]>bel[y]) swap(x,y);
	if(m1[bel[x]][bel[y]]&(sta[x]&sta[y])) return c[bel[x]][bel[y]];
	else if(m1[bel[x]][bel[y]]&(sta[x]|sta[y])) return c[bel[x]][bel[y]]+1;
	else if(m2[bel[x]][bel[y]]&(sta[x]&sta[y])) return c[bel[x]][bel[y]]+1;
	else return c[bel[x]][bel[y]]+2;
}

inline ll Solve(){
	cin>>n>>m>>k;
	st[0]=1;
	for(int i=1;i<=m;i++){
		cin>>s[i];
		st[i]=st[i-1]+s[i-1].size();
		for(int j=0;j<s[i].size();j++){
			if(j){
				e[st[i]+j].push_back({st[i]+j-1,1});
				e[st[i]+j-1].push_back({st[i]+j,1});
			}
			bel[st[i]+j]=s[i][j]-'a'+1;
			e[st[i]+j].push_back({n+bel[st[i]+j],1});
			e[n+bel[st[i]+j]].push_back({st[i]+j,0});
		}
	}
	for(int i=1;i<=k;i++) BFS(n+i,d[i]);
	for(int i=1;i<=k;i++){
		for(int j=1;j<=k;j++) c[i][j]=d[i][n+j]-(i!=j);
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=k;j++){
			sta[i]|=(d[j][i]==c[j][bel[i]])<<j-1;
		}
		v[bel[i]][sta[i]]++;
		p[bel[i]].push_back(i);
	}

	ll ans=0;
	for(int i=1;i<=k;i++){
		ans+=1ll*p[i].size()*(p[i].size()-1)/2;
		for(int j=0;j<k;j++){
			for(int t=0;t<(1<<k);t++) if(~t>>j&1) v[i][t|(1<<j)]+=v[i][t];
		}
		for(int j=i+1;j<=k;j++){
			for(int t=1;t<=k;t++){
				m1[i][j]|=(c[i][j]==c[i][t]+c[t][j]+1)<<t-1;
				m2[i][j]|=(c[i][j]+1==c[i][t]+c[t][j]+1)<<t-1;
			}
			for(int x:p[j]){
				ll c0=p[i].size()-v[i][(1<<k)-1^m1[i][j]&sta[x]];
				ll c2=v[i][(1<<k)-1^m1[i][j]^m2[i][j]&sta[x]];
				ll c1=p[i].size()-c0-c2;
				ans+=c0*c[i][j]+c1*(c[i][j]+1)+c2*(c[i][j]+2);
			}
		}
	}

	for(int i=1;i<=m;i++){
		for(int j=0;j<s[i].size();j++){
			for(int t=max(0,j-2*k);t<j;t++){
				ans-=Dist(st[i]+t,st[i]+j);
				ans+=min(Dist(st[i]+t,st[i]+j),j-t);
			}
		}
	}

	for(int i=1;i<=k;i++){
		for(int j=1;j<=n+k;j++) d[i][j]=0;
		for(int j=0;j<(1<<k);j++) v[i][j]=0;
		for(int j=1;j<=k;j++) c[i][j]=m1[i][j]=m2[i][j]=0;
		p[i].clear(),p[i].shrink_to_fit();
	}
	for(int i=1;i<=n+k;i++) e[i].clear(),e[i].shrink_to_fit();
	for(int i=1;i<=n;i++) bel[i]=sta[i]=0;
	for(int i=1;i<=m;i++) s[i].clear(),s[i].shrink_to_fit();

	return ans;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	for(int o=1;o<=T;o++) cout<<"Case #"<<o<<": "<<Solve()<<endl;

	return 0;
}
```

### 67. One, Two, Three

å‘ƒå‘ƒé¦–å…ˆå› ä¸ºæ˜¯ $(1,2,3)$ å’Œ $(3,2,1)$ï¼Œæ‰€ä»¥è‚¯å®š $2$ æ˜¯ç‰¹æ®Šçš„ã€‚

è€ƒè™‘å…ˆè®© $(1,3),(3,1)$ åŒ¹é…æˆåŒºé—´ï¼Œæœ€åå†å¾€é‡Œé¢æ”¾ $2$ã€‚å‡è®¾é€‰äº† $x$ å¯¹ $(1,3)$ ä»¥åŠ $y$ å¯¹ $(3,1)$ï¼Œé‚£ä¹ˆå¤„äºè´ªå¿ƒçš„ç›®çš„ï¼Œç”¨äºåŒ¹é…çš„ç†åº”æ˜¯å‰ $x$ ä¸ª $1$ å‰ $y$ ä¸ª $3$ï¼Œä»¥åŠå $y$ ä¸ª $1$ å $x$ ä¸ª $3$ã€‚åŒæ—¶æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡è°ƒæ•´ä½¿å¾— $(1,3)$ å¯¹ä¹‹é—´ï¼Œ$(3,1)$ å¯¹ä¹‹é—´äº’ç›¸ä¸æ„æˆåŒ…å«å…³ç³»ï¼Œè€Œç­”æ¡ˆä¸å˜ã€‚

ä»¤ $\displaystyle c_{k}(l,r)=\sum_{i=l}^r[a_i=k],s_k(p)=c_k(1,p)$ã€‚

ç”±äºè¦å¯¹ $2$ åŒ¹é…ï¼Œè€ƒè™‘ Hall å®šç†ï¼Œè®¾ $f(l,r),g(l,r)$ åˆ†åˆ«è¡¨ç¤º $[l,r]$ å†… $(1,3)$ å¯¹å’Œ $(3,1)$ å¯¹çš„æ•°é‡ï¼š

- $f(l,r)+g(l,r)\leq c_2(l,r)$ã€‚
- $f(l,r)=\max(x-c_1(1,l-1)-c_3(r+1,n),0)$ã€‚
- $g(l,r)=\max(y-c_3(1,l-1)-c_1(r+1,n),0)$ã€‚

äºŒä¸‰å¼ä»£å…¥ä¸€å¼æ‹† max å¯ä»¥å¾—åˆ° $4$ æ¡é™åˆ¶ï¼š

- $0 \leq c_2(l,r)$ã€‚
- $x \leq c_2(l,r)+c_1(1,l-1)+c_3(r+1,n)$ã€‚
- $y\leq c_2(l,r)+c_3(1,l-1)+c_1(r+1,n)$ã€‚
- $x+y\leq c_2(l,r)+c_1(1,l-1)+c_3(r+1,n)+c_3(1,l-1)+c_1(r+1,n)$ã€‚

å°† $c_k$ æ‹†æˆ $s_k$ ä¹‹åå¯ä»¥å¾—åˆ° $l,r$ å¯¹ $x,y,x+y$ çš„é™åˆ¶ï¼Œå¯¹æœ‰å…³ $l$ çš„å¼å­æ±‚å‰ç¼€æœ€å€¼å¯ä»¥å¾—åˆ° $x,y,x+y$ çš„ä¸Šç•Œï¼Œæ ¹æ® Hall å®šç†ï¼Œéšä¾¿æ‰¾ä¸€ç»„ $(x_0,y_0)$ å°±æ˜¯å¯¹çš„ã€‚

æ„é€ è§£è€ƒè™‘å°†æ‰€æœ‰ $(1,3)$ å’Œ $(3,1)$ å¯¹æŠ½å‡ºæ¥ï¼Œå¯¹æ‰€æœ‰ $2$ ä»å·¦åˆ°å³ä¼˜å…ˆåŒ¹é…å³ç«¯ç‚¹æœ€å·¦çš„å³å¯ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ï¼Œç“¶é¢ˆåœ¨äºæ„é€ è§£ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=6e5+9;
const int inf=1e9+7;

int a[N],rk[N],cnt[4][N],p[4][N],n;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	int x=inf,y=inf,xy=inf,lx=inf,ly=inf,lxy=inf;
	for(int i=1;i<=n;i++){
		for(int j:{1,2,3}) cnt[j][i]=cnt[j][i-1];
		p[a[i]][rk[i]=++cnt[a[i]][i]]=i;
	}
	x=y=xy=min(cnt[1][n],min(cnt[2][n],cnt[3][n]));
	for(int i=1;i<=n;i++){
		lx=min(lx,-cnt[2][i-1]+cnt[1][i-1]);
		ly=min(ly,-cnt[2][i-1]+cnt[3][i-1]);
		lxy=min(lxy,-cnt[2][i-1]+cnt[1][i-1]+cnt[3][i-1]);
		x=min(x,lx+cnt[2][i]-cnt[3][i]+cnt[3][n]);
		y=min(y,ly+cnt[2][i]-cnt[1][i]+cnt[1][n]);
		xy=min(xy,lxy+cnt[2][i]-cnt[3][i]+cnt[3][n]-cnt[1][i]+cnt[1][n]);
	}
	xy=min(xy,x+y),x=min(x,xy),y=xy-x;

	cout<<x+y<<endl;
	priority_queue<array<int,2>> q;
	for(int i=1;i<=n;i++){
		if(a[i]==1){
			if(rk[i]<=x) q.push({-p[3][cnt[3][n]-(x-rk[i]+1)+1],-i});
		}else if(a[i]==3){
			if(rk[i]<=y) q.push({-p[1][cnt[1][n]-(y-rk[i]+1)+1],-i});
		}else if(a[i]==2){
			if(q.size()){
				cout<<-q.top()[1]-1<<' '<<i-1<<' '<<-q.top()[0]-1<<endl;
				q.pop();
			}
		}
	}

	return 0;
}
```

### 68. Lonely King

é¦–å…ˆæœ€ä¼˜ç¼©è¾¹æ–¹å¼è‚¯å®šæ˜¯ç›´æ¥ç¼©åˆ°å¶å­ï¼Œå› æ­¤æ•´ä½“å½¢æ€ç±»ä¼¼å¯¹è¾¹è¿›è¡Œå‰–åˆ†ã€‚

è®¾ $f_x(k)$ è¡¨ç¤ºç»è¿‡ $x$ è¿å‡ºå»çš„è¾¹è¿åˆ°çš„ç‚¹ç‚¹æƒä¸º $k$ æ—¶ç­”æ¡ˆæœ€å°å€¼ï¼Œæœ‰è½¬ç§»ï¼š$\displaystyle f_x(k)=\min_{x\rightarrow y}( f_y(k)+\sum_{z\neq y,x\rightarrow z}f_z(c_x)$ã€‚

é‚£ä¹ˆæ˜¾ç„¶åœ°ï¼Œ$f_x(k)$ æ˜¯ä¸‹å‡¸çš„ï¼Œè‡³æ­¤å¯ä»¥ä½¿ç”¨ç›´æ¥ä¸€äº›æ‰‹æ³•ç›´æ¥ç»´æŠ¤ã€‚

è€ƒè™‘å¯¹æ¯ä¸ªèŠ‚ç‚¹ä½¿ç”¨æè¶…çº¿æ®µæ ‘ç»´æŠ¤ $f_x(k)$ï¼Œéœ€è¦çš„æ“ä½œæ˜¯å…¨å±€å‡å’Œåˆå¹¶ï¼Œå¯ä»¥ç›´æ¥æ‰“ tagï¼Œä¹Ÿå¯ä»¥è®°å½•åå·®å€¼ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e5+9;
const int inf=1e9+7;
const ll lnf=1e18;
const int V=1e6;

struct Line{
	ll k,b;
	Line(){}
	Line(ll _k,ll _b){k=_k,b=_b;}
	inline ll operator ()(ll x){return k*x+b;}
};

struct Node{
	ll tag;
	int lc,rc;
	Line f=Line(inf,lnf);
}tr[N<<6];

int cnt;
inline int Allc(){return ++cnt;}
inline void Push(int &x,ll k){
	if(!x) return ;
	tr[x].f.b+=k,tr[x].tag+=k;
}
inline void PushDown(int x){
	if(tr[x].tag){
		Push(tr[x].lc,tr[x].tag);
		Push(tr[x].rc,tr[x].tag);
		tr[x].tag=0;
	}
}
inline bool Beat(int L,int R,Line f,Line g){return f(L)<g(L)&&f(R)<g(R);}
inline bool NoUse(int L,int R,Line f,Line g){return f(L)>=g(L)&&f(R)>=g(R);}
inline bool Invalid(Line f){return f.k>=inf/10||f.b>=lnf/10;}
inline void Update(int &x,int L,int R,int l,int r,Line f){
	if(!x) x=Allc();
	if(l<=L&&R<=r){
		if(L<R) PushDown(x);
		if(Beat(L,R,f,tr[x].f)) tr[x].f=f,tr[x].tag=0;
		else if(L<R){
			int mid=L+R>>1;
			if(!NoUse(L,mid,f,tr[x].f)) Update(tr[x].lc,L,mid,l,r,f);
			if(!NoUse(mid+1,R,f,tr[x].f)) Update(tr[x].rc,mid+1,R,l,r,f);
		}
		return ;
	}
	PushDown(x);
	int mid=L+R>>1;
	if(l<=mid) Update(tr[x].lc,L,mid,l,r,f);
	if(r>mid) Update(tr[x].rc,mid+1,R,l,r,f);
}
inline ll Min(int x,int L,int R,int pos){
	if(!x) return lnf;
	if(L==R) return tr[x].f(pos);
	PushDown(x);
	int mid=L+R>>1;
	if(pos<=mid) return min(tr[x].f(pos),Min(tr[x].lc,L,mid,pos));
	else return min(tr[x].f(pos),Min(tr[x].rc,mid+1,R,pos));
}
inline void Merge(int &x,int y,int L,int R){
	if(!y||Invalid(tr[y].f)) return ;
	if(!x||Invalid(tr[x].f)) return x=y,void();
	Update(x,L,R,L,R,tr[y].f);
	if(L==R) return ;
	int mid=L+R>>1;
	PushDown(x),PushDown(y);
	Merge(tr[x].lc,tr[y].lc,L,mid);
	Merge(tr[x].rc,tr[y].rc,mid+1,R);
}

vector<int> e[N];
int c[N],fa[N],root[N],n;
inline void Solve(int x){
	if(!e[x].size()){
		Update(root[x],1,V,1,V,Line(c[x],0));
	}else{
		ll sum=0;
		for(int y:e[x]){
			Solve(y);
			ll t=Min(root[y],1,V,c[x]);
			sum+=t;
			Push(root[y],-t);
			Merge(root[x],root[y],1,V);
		}
		Push(root[x],sum);
	}
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=2;i<=n;i++) cin>>fa[i],e[fa[i]].push_back(i);
	for(int i=1;i<=n;i++) cin>>c[i];

	if(n==1){
		cout<<0<<endl;
		return 0;
	}

	Solve(1);

	cout<<Min(root[1],1,V,c[1])<<endl;

	return 0;
}
```

### 69. Beautiful Sequence

é¦–å…ˆç­”æ¡ˆå¯ä»¥åˆ»ç”»æˆ $\displaystyle n-\sum_{i=1}^{n-1}[a_i\neq a_{i+1}]+[a_{i-1}>a_i<a_{i+1}]$ï¼ŒåŸç†æ˜¯ç›¸é‚»çš„ä¸åŒå€¼å°çš„é‚£ä¸ªè‚¯å®šå€’é—­äº†ï¼Œä½†æ˜¯ä¸€ä¸ªç‚¹ä¸ä¼šå€’é—­ä¸¤æ¬¡ã€‚

é‚£ä¹ˆå‡è®¾å½“å‰æœ‰ $c$ ä¸ªä¸€æ ·çš„æ•°ï¼Œè°ƒæ•´æ³•å¯çŸ¥ï¼Œ**åŸºæœ¬ä¸Š**é™¤äº†å¡«æˆ $c$ ä¸ªé•¿åº¦ä¸º $1$ çš„è°·æ®µæˆ–å¡« $1$ ä¸ªé•¿åº¦ä¸º $c$ çš„æ®µä»¥å¤–å‡ä¸ä¼˜ã€‚ç‰¹åˆ«åœ°ï¼Œå¡«æˆ $c$ ä¸ªé•¿åº¦ä¸º $1$ çš„è°·æ®µæœ‰ $1$ çš„é¢å¤–è´¡çŒ®ã€‚ä¸ä»ä¸Šè¿°å¼å­åˆ»ç”»è¿™ç‚¹åˆ™æ²¡é‚£ä¹ˆæ˜¾ç„¶ã€‚

è€ƒè™‘ä»å¤§åˆ°å°å¡«æ•°ï¼Œé‚£ä¹ˆå¡« $c$ ä¸ªé•¿åº¦ä¸º $1$ çš„è°·æ®µç›¸å½“äºåˆå¹¶ $c+1$ ä¸ªè¿ç»­æ®µï¼Œè€Œå¡« $1$ ä¸ªé•¿åº¦ä¸º $c$ çš„æ®µè‡³å¤šå¯ä»¥æ–°å¢ä¸€ä¸ªè¿ç»­æ®µï¼Œæœ€åè¿ç»­æ®µæœ‰å¤šä¸ªç›´æ¥åˆå¹¶æˆä¸€ä¸ªå³å¯ã€‚

å› æ­¤é—®é¢˜è½¬åŒ–ä¸ºï¼Œç»™å®šåºåˆ— $a_i$ï¼Œæ±‚ $\sum x_i$ æœ€å¤§å€¼ä½¿å¾— $\displaystyle \forall i,x_i\in\{0,1\},\sum_{j=1}^i x_ia_i\leq i$ã€‚è€ƒè™‘ç›´æ¥è´ªå¿ƒï¼Œä» $i-1$ æ¨åˆ° $i$ çš„æ—¶å€™ï¼Œèƒ½ç›´æ¥åŠ å…¥ $a_i$ è‚¯å®šç›´æ¥åŠ å…¥ $a_i$ äº†ï¼Œ è€ƒè™‘æ— æ³•åŠ å…¥ $a_i$ è‚¯å®šæ˜¯å› ä¸º $i-1$ çš„ $\sum x_ia_i$ å¤ªå¤§äº†ï¼Œå› æ­¤æ¯æ¬¡è´ªå¿ƒè€ƒè™‘æŠŠ $\sum x_ia_i$ å½“ä½œç¬¬äºŒå…³é”®å­—ï¼Œå¦‚æœæ— æ³•ç›´æ¥åŠ å…¥å°±å°è¯•æŠŠ $i-1$ çš„ç­”æ¡ˆä¸­æœ€å¤§å€¼æ¢æ‰ï¼Œä¸éš¾å‘ç°è¿™æ ·ä¸å½±å“ç­”æ¡ˆæ­£ç¡®æ€§ã€‚

æ—¶é—´å¤æ‚åº¦ $O(n\log n)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=3e5+9;

int a[N],c[N],n,m;

inline void Solve(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];

	vector<int> val(a,a+n+1);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()),val.end());
	m=val.size()-1;

	for(int i=1;i<=n;i++){
		c[lower_bound(val.begin(),val.end(),a[i])-val.begin()]++;
	}
	
	int ans=n-m+1,sum=0;
	priority_queue<int> q;
	for(int i=m;i>=1;i--){
		q.push(c[i]+1),sum+=c[i]+1,ans++;
		if(sum>=m-i+1) sum-=q.top(),ans--,q.pop();
		c[i]=0;
	}

	cout<<ans<<endl;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int T;
	cin>>T;
	while(T--) Solve();

	return 0;
}
```

### 73. Sets May Be Good

è€ƒè™‘æŠŠç­”æ¡ˆåˆ»ç”»æˆï¼š$\displaystyle \sum_{x\in\Z_2^n} (\sum_{(i,j)\in E} x_ix_j)\bmod 2$ï¼Œè¿™æ˜¯äºŒæ¬¡å‹ï¼Œä»¤ $A$ ä¸ºåŸå›¾çš„é‚»æ¥çŸ©é˜µï¼Œé‚£ä¹ˆè¯¥å¼ç­‰åŒäº $\displaystyle \sum_{x\in\Z_2^n} x^TAx\bmod 2$ã€‚

è€ƒè™‘å°†å˜æ¢ $R$ ä½œç”¨äº $x$ï¼Œä½¿å¾— $x$ ä»ç„¶èƒ½å¤Ÿå–é $\Z_2^n$ï¼Œå³ï¼š$\displaystyle \sum_{x\in\Z_2^n} (Rx)^TA(Rx)\bmod 2=\sum_{x\in\Z_2^n} x^T(R^TAR)x\bmod 2$ã€‚

è¿™è¯´æ˜æŠŠ $A$ å˜æ¢åˆ° $R^TAR$ ç­”æ¡ˆä»æ—§ä¸å˜ï¼Œç»„åˆæ„ä¹‰å°±æ˜¯æ–½åŠ åŸºæœ¬è¡Œå˜æ¢ä¹‹åå†æ–½åŠ ç›¸åŒçš„åŸºæœ¬åˆ—å˜æ¢ã€‚

å› æ­¤è€ƒè™‘æ¶ˆå…ƒï¼š

- é¦–å…ˆï¼Œå…ˆå°† $A_{1,i}$ ç¿»æŠ˜åˆ° $A_{i,1}$ ä¸Šï¼Œå³ $A_{i,1}\leftarrow A_{1,i}+A_{i,1}$ï¼Œ$A_{1,i}\leftarrow 0$ã€‚
- ç„¶åæ‰¾åˆ°è¡Œ $i$ ä½¿å¾— $A_{i,1}\neq 0$ï¼Œå°†å…¶ä¸ç¬¬ $2$ è¡Œäº¤æ¢ï¼ŒåŒæ—¶äº¤æ¢ç¬¬ $2$ åˆ—ä¸ç¬¬ $i$ åˆ—ã€‚
- ä¹‹åï¼Œå¯¹äºç¬¬ $3$ è¡ŒåŠä»¥åçš„æ‰€æœ‰ $A_{i,1}\neq 0$ çš„è¡Œ $i$ï¼ŒæŠŠç¬¬ $2$ è¡Œä¸ç¬¬ $i$ è¡Œç›¸æ¶ˆï¼Œå³ $A_{i,j}\leftarrow A_{i,j}+A_{2,j}$ã€‚åŒæ—¶æŠŠç¬¬ $2$ åˆ—åŠ åˆ°ç¬¬ $i$ åˆ—ä¸Šã€‚

- æ­¤æ—¶ç¬¬ $1$ åˆ—åªæœ‰ $A_{1,1},A_{2,1}$ æœ‰å€¼ï¼Œç¬¬ $1$ è¡Œåªæœ‰ $A_{1,1}$ æœ‰å€¼ï¼Œé€’å½’åœ°æ¶ˆå…ƒå³å¯ã€‚

æœ€ååªæœ‰ $A_{i,i},A_{i+1,i}$ æœ‰å€¼ï¼Œé‚£ä¹ˆæ­¤æ—¶å½¢æ€å°±æ˜¯ä¸€æ¡æœ‰è‡ªç¯çš„é“¾ï¼Œå¯ä»¥é€šè¿‡ç®€å•çš„ DP è§£å†³ã€‚

æ¶ˆå…ƒå¯ä»¥ç”¨ bitset åŠ ä»¥ä¼˜åŒ–ï¼Œæ—¶é—´å¤æ‚åº¦ $O(\dfrac {n^3}w)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e3+9;
const int mod=998244353;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

int f[N][2][2],n,m;
bitset<N> a[N];

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		a[u].flip(v);
	}

	for(int i=1;i<n;i++){
		for(int j=i+1;j<=n;j++) a[j][i]=a[j][i]^a[i][j],a[i][j]=0;
		int p=i+1;
		while(p<=n&&!a[p][i]) p++;
		if(p>n) continue ;
		else if(p!=i+1){
			swap(a[i+1],a[p]);
			for(int j=1;j<=n;j++){
				a[j][i+1]=a[j][p]^a[j][i+1];
				a[j][p]=a[j][p]^a[j][i+1];
				a[j][i+1]=a[j][p]^a[j][i+1];
			}
		}
		bitset<N> b;
		for(int j=i+2;j<=n;j++){
			if(!a[j][i]) continue ;
			a[j]^=a[i+1];
			b.set(j);
		}
		for(int j=1;j<=n;j++) if(a[j][i+1]) a[j]^=b;
	}

	f[0][0][0]=1;
	for(int i=1;i<=n;i++){
		for(int s:{0,1}){
			for(int p:{0,1}){
				for(int q:{0,1}){
					AddAs(f[i][s^(q&a[i][i])^(p&q&a[i][i-1])][q],f[i-1][s][p]);
				}
			}
		}
	}
	
	int ans=0;
	for(int p:{0,1}) AddAs(ans,f[n][0][p]);

	cout<<ans<<endl;

	return 0;
}
```

### 75. Fast Spanning Tree

è€ƒè™‘æŠ˜åŠæŠ¥è­¦å™¨ï¼ŒæŠŠæ¯ä¸ªé™åˆ¶å‰©ä½™çš„é‡æ‹†æˆä¸¤åŠåˆ†ç»™ä¸¤ä¸ªè¿é€šå—ï¼Œè¿™æ ·å°±æ˜¯ $O(n\log^2 m+n\log m\log V)$ çš„ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll=long long;
const int N=3e5+9;

ll wsu[N];
int fa[N],u[N],v[N],lim[N],n,m;
priority_queue<int> td;
priority_queue<pair<ll,int>> cn[N];
inline int Find(int x){return fa[x]==x?x:fa[x]=Find(fa[x]);}
inline void Upd(int x){
	while(cn[x].size()&&wsu[x]>=-cn[x].top().first){
		td.push(-cn[x].top().second);
		cn[x].pop();
	}
}
inline void Merge(int x,int y){
	x=Find(x),y=Find(y);
	if(x==y) return ;
	if(cn[x].size()<cn[y].size()) swap(x,y);
	fa[y]=x;
	wsu[x]+=wsu[y];
	while(cn[y].size()) cn[x].push(cn[y].top()),cn[y].pop();
	Upd(x);
}
vector<int> ans;
inline bool Work(){
	while(td.size()){
		int i=-td.top();
		td.pop();
		if(Find(u[i])==Find(v[i])) continue ;
		if(wsu[Find(u[i])]+wsu[Find(v[i])]>=lim[i]){
			Merge(u[i],v[i]);
			ans.push_back(i);
		}else{
			int dlt=lim[i]-(wsu[Find(u[i])]+wsu[Find(v[i])])+1>>1;
			cn[Find(u[i])].push({-(dlt+wsu[Find(u[i])]),i});
			cn[Find(v[i])].push({-(dlt+wsu[Find(v[i])]),i});
		}
	}
	return 0;
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>wsu[i],fa[i]=i;
	for(int i=1;i<=m;i++){
		cin>>u[i]>>v[i]>>lim[i];
		int dlt=lim[i]+1>>1;
		cn[u[i]].push({-dlt,i});
		cn[v[i]].push({-dlt,i});
	}

	for(int i=1;i<=n;i++) Upd(i);
	while(Work()) ;

	cout<<ans.size()<<endl;
	for(int x:ans) cout<<x<<' ';cout<<endl;

	return 0;
}
```

### 77. Honorable Mention

é¦–å…ˆä»¥ $k$ ä¸ºè‡ªå˜é‡ï¼Œ$[l,r]$ çš„ $k$ å­æ®µå’Œæ˜¯å‡¸çš„ï¼Œæ„Ÿæ€§ç†è§£å°±æ˜¯å¦‚æœä¸¤ä¸ªè¾ƒå¤§åŒºé—´æœ‰äº¤å°±å¯ä»¥ç›´æ¥åˆå¹¶ï¼Œæ‰€ä»¥ä¸€å®šæ˜¯ä»å¤§åˆ°å°é€‰å‡ºè‹¥å¹²æ®µè¿ç»­åŒºé—´ï¼Œç„¶åå°†è¿™äº›åŒºé—´åˆ†è£‚ï¼Œæœ€åå†é€‰ä¸€äº›è´Ÿçš„å•ç‚¹ï¼Œä»£æ•°è¯æ˜æ˜¯å®¹æ˜“çš„ã€‚

å»ºç«‹é™æ€çš„çº¿æ®µæ ‘ç»´æŠ¤è¿™ä¸ªå‡¸åŒ…ï¼Œå¯¹äºæ¯æ¬¡è¯¢é—®ï¼Œè€ƒè™‘ wqs äºŒåˆ†æ–œç‡åˆ‡å‡¸åŒ…ï¼Œä»¥ç­”æ¡ˆä¸ºç¬¬ä¸€å…³é”®å­—ï¼Œæ®µæ•°ä¸ºç¬¬äºŒå…³é”®å­— DP é€‰å–æœ€å¤§å€¼ï¼Œæ—¶é—´å¤æ‚åº¦ $O(n\log^2 n\log V)$ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=5e4+9;
const int V=1e9;
const ll inf=1e18,hnf=1e12;

int a[N],n,q;

struct Node{
	int l,r;
	vector<ll> f[2][2],df[2][2];
}tr[N<<2];

inline vector<ll> Shift(vector<ll> f,int k){
	f.erase(f.begin(),f.begin()+k);
	return f;
}
inline vector<ll> Merge(vector<ll> f,vector<ll> g){
	adjacent_difference(f.begin(),f.end(),f.begin());
	adjacent_difference(g.begin(),g.end(),g.begin());
	vector<ll> h(f.size()+g.size()-1);
	h[0]=f[0]+g[0];
	merge(f.begin()+1,f.end(),g.begin()+1,g.end(),h.begin()+1,greater<ll>());
	partial_sum(h.begin(),h.end(),h.begin());
	return h;
}
inline void ChMax(vector<ll> &f,vector<ll> g){
	int len=max(f.size(),g.size());
	f.resize(len,LLONG_MIN);
	g.resize(len,LLONG_MIN);
	for(int i=0;i<len;i++) f[i]=max(f[i],g[i]);
}

inline void DF(int x){
	for(int i:{0,1}){
		for(int j:{0,1}){
			tr[x].df[i][j].resize(tr[x].f[i][j].size());
			adjacent_difference(tr[x].f[i][j].begin(),tr[x].f[i][j].end(),tr[x].df[i][j].begin());
			tr[x].df[i][j][0]=LLONG_MAX;
		}
	}
}
inline void PushUp(int x){
	for(int i:{0,1}){
		for(int j:{0,1}){
			for(int k:{0,1}){
				ChMax(tr[x].f[i][j],Shift(Merge(tr[x<<1].f[i][k],tr[x<<1|1].f[k][j]),k));
			}
		}
	}
	DF(x);
}

inline void Build(int x,int l,int r){
	tr[x].l=l,tr[x].r=r;
	if(tr[x].l==tr[x].r){
		for(int i:{0,1}) for(int j:{0,1}) tr[x].f[i][j]={-(i|j)*hnf,a[l]};
		DF(x);
		return ;
	}
	int mid=tr[x].l+tr[x].r>>1;
	Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
	PushUp(x);
}

struct Data{
	array<ll,2> f[2][2];
	friend inline Data operator +(Data x,Data y){
		Data z;
		for(int i:{0,1}){
			for(int j:{0,1}){
				z.f[i][j]={LLONG_MIN,0};
				for(int k:{0,1}){
					z.f[i][j]=max(z.f[i][j],{x.f[i][k][0]+y.f[k][j][0],x.f[i][k][1]+y.f[k][j][1]-k});
				}
			}
		}
		return z;
	}
};

inline Data GetData(int x,ll dlt){
	Data t;
	for(int i:{0,1}){
		for(int j:{0,1}){
			int p=upper_bound(tr[x].df[i][j].begin(),tr[x].df[i][j].end(),dlt,greater<ll>())-tr[x].df[i][j].begin()-1;
			t.f[i][j]={(i||j)&&!p||!~p?-inf:tr[x].f[i][j][p]-p*dlt+i*dlt,p};
		}
	}
	return t;
}
inline Data Query(int x,int l,int r,ll dlt){
	if(l<=tr[x].l&&tr[x].r<=r) return GetData(x,dlt);
	int mid=tr[x].l+tr[x].r>>1;
	if(r<=mid) return Query(x<<1,l,r,dlt);
	else if(l>mid) return Query(x<<1|1,l,r,dlt);
	else return Query(x<<1,l,r,dlt)+Query(x<<1|1,l,r,dlt);
}
inline ll Calc(int l,int r,int k){
	ll L=-V,R=V;
	while(L+1<R){
		ll mid=L+R>>1;
		if(Query(1,l,r,mid).f[0][0][1]>=k) L=mid;
		else R=mid;
	}
	return Query(1,l,r,L).f[0][0][0]+1ll*L*k;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];

	Build(1,1,n);
	while(q--){
		int l,r,k;
		cin>>l>>r>>k;
		cout<<Calc(l,r,k)<<endl;
	}

	return 0;
}
```

### 80. Bit Component

é¦–å…ˆè€ƒè™‘æ ¼é›·ç ï¼Œç„¶è€Œå‘ç° $n=13$ ä¹Ÿæœ‰è§£ï¼Œè€ƒå¯Ÿå½¢æ€ï¼š

```
      oooooo 
   oooo    oo
 oooo   oo   
oo  ooooo    
```

å¯ä»¥çœ‹å‡ºï¼Œæ–¹æ³•æ˜¯å°†æ¬¡é«˜ä½å’Œæœ€é«˜ä½è”é€šï¼Œç„¶åä¸‹é¢åˆ™é€šè¿‡ä¸€ä¸ª `110...001` å’Œä¹‹å‰æ ¼é›·ç ä¸­ `100...001` è”é€šï¼Œç„¶ååˆ¨å»æœ€é«˜ä½å’Œæ¬¡é«˜ä½å†å¡«ä¸€éå°ä¸€å·çš„æ ¼é›·ç ï¼Œæœ‰é‡çš„æ”¾åœ¨ä¸€èµ·å³å¯ï¼Œæœ€å `110...000` æ”¶å°¾ï¼Œå†è¡¥ä¸Šæ¼çš„ `010...001`ã€‚

åŒæ—¶ä¹Ÿå¯ä»¥è¯æ˜æœ‰è§£çš„é›†åˆå°±æ˜¯ $\mathbb{Z}\cap\displaystyle \bigcup _{k}(3\times2^{k-2},2^k)$ ã€‚

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=(1<<18)+9;

int a[N];

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	int n;
	cin>>n;

	int k=__lg(n);
	for(int i=0;i<=k;i++){
		for(int j=(1<<i);j<(1<<i+1);j++){
			a[j]=(a[j^(1<<i)]^a[(1<<i)-1])|(1<<i);
		}
	}

	if(n==(1<<k+1)-1){
		cout<<"YES"<<endl;
		for(int i=1;i<=n;i++) cout<<a[i]<<' ';cout<<endl;
	}else if(k<3) cout<<"NO"<<endl;
	else if(n<=((1<<k)|(1<<k-1))) cout<<"NO"<<endl;
	else{
		cout<<"YES"<<endl;
		for(int i=1;i<(1<<k)-1;i++) cout<<a[i]<<' ';
		for(int i=1;i<(1<<k-1);i++){
			if((a[i]|(1<<k)|(1<<k-1))<=n) cout<<(a[i]|(1<<k)|(1<<k-1))<<' ';
			cout<<(a[i]|(1<<k))<<' ';
		}
		cout<<(1<<k)<<' ';
		cout<<((1<<k)|(1<<k-1))<<' ';
		cout<<(1<<k-1)<<' ';
		cout<<endl;
	}

	return 0;
}
```
