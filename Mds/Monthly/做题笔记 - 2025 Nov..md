# 做题笔记 - 2025 Nov.

## 题目整理

### [CF1770] F. Koxia and Sequence

人类智慧还是太厉害了。

考虑对称性，如果 $n$ 为偶数且 $a$ 不是回文序列，那么可以直接反转整个序列得到一个和原来本质不同且异或和相同的序列，贡献就消掉了。而如果 $n$ 为偶数且 $a$ 是回文序列，那么异或和本来就是 $0$。所以 $n$ 为偶数时的答案就是 $0$。

如果 $n$ 是奇数，那么仍然可以对 $a[2:n]$ 做相同的事情，答案就是所有 $a_1$ 的异或和。

对按位或为 $y$ 的限制容斥，即计算 $\displaystyle \bigoplus_{z\subseteq y} f(n,x,z)$，其中 $f(n,x,z)$ 表示满足 $n$ 和 $x$ 的限制下 $\displaystyle \bigcup_{i=1}^n a_i=z$ 的序列 $a_1$ 的异或和。即 :

$\begin{array} \displaystyle f(n,x,z)\\\displaystyle=\bigoplus_{\sum_{i=1}^n a_i=x} a_1\prod_{i=1}^n[a_i\subseteq z]\\\displaystyle=\bigoplus_{v\subseteq z} v((\sum_{\sum_{i=1}^n a_i=x\wedge a_1=v}\prod_{i=1}^n[a_i\subseteq z])\bmod 2)\\\displaystyle=\bigoplus_{i\in z} 2^i((\sum_{\sum_{i=1}^n a_i=x\wedge i\in a_1}\prod_{i=1}^n[a_i\subseteq z])\bmod 2)\\\displaystyle=\bigoplus_{i\in z} 2^i((\sum_{\sum_{i=1}^n a_i=x-2^i}[a_1\subseteq z-2^i]\prod_{i=2}^n[a_i\subseteq z])\bmod 2)\end{array}$

**不妨发扬人类智慧**，根据 Lucas 定理，有 $\displaystyle \dbinom{n}{m}\bmod 2=[m\subseteq n]$，因此：

$\begin{array} \displaystyle f(n,x,z)\\\displaystyle=\bigoplus_{i\in z} 2^i((\sum_{\sum_{i=1}^n a_i=x-2^i}\binom{z-2^i}{a_1}\prod_{i=2}^n\dbinom{z}{a_i})\bmod 2)\\\displaystyle=\bigoplus_{i\in z} 2^i(\dbinom{nz-2^i}{x-2^i}\bmod 2)\\\displaystyle=\bigoplus_{i\in z} 2^i[nz-2^i\subseteq x-2^i]\end{array}$

于是可以 $O(\log z)$ 计算 $f(n,x,z)$，总复杂度 $O(y\log y)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll=long long;

signed main(){
	ll n,x,y;
	cin>>n>>x>>y;

	if(~n&1){
		cout<<0<<endl;
		return 0;
	}

	ll ans=0;
	for(ll s=y;s;s=y&(s-1)){
		ll res=0;
		for(int i=0;i<=__lg(s);i++){
			if(~s>>i&1) continue ;
			ll p=x-(1ll<<i),q=n*s-(1ll<<i);
			if(p<0||q<0) continue ;
			if((p|q)==q) res|=1ll<<i;
		}
		ans^=res;
	}

	cout<<ans<<endl;

	return 0;
}
```



### [JRKSJ R4] Salieri

二分答案 $t$，转化为问 $cnt_i\times v_i\geq t$ 的 $i$ 有多少个。

将所有模式串全部插到 Trie 上跑 ACAM，那么 $cnt_i$ 就是在 fail 树上以 $i$ 的终止节点为根子树内所有节点被询问串遍历次数之和，或者也可以看成询问串每次对所有遍历到的节点做到根的链加。那么，对于询问串 $S$，不同的 $cnt_i$ 只有 $O(|S|)$ 段，即遍历到的节点在 fail 树上的虚树。对于每一段，在主席树上查询 $\displaystyle v_i\geq \lceil\dfrac{t}{cnt}\rceil$ 的 $i$ 的个数即可。

时间复杂度 $O(L|\Sigma|+L\log L)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=1e5+9;
const int L=5e5+9;
const int V=1e3;
const int lgL=2e1;

namespace PSgT{
	struct Node{
		int lc,rc,siz;
	}tr[N<<5];
	int cnt;
	inline int Allc(){return ++cnt;}
	inline int Clone(int x){int y=Allc();tr[y]=tr[x];return y;}
	inline void PushUp(int x){tr[x].siz=tr[tr[x].lc].siz+tr[tr[x].rc].siz;}
	inline void Insert(int &x,int L,int R,int pos){
		x=Clone(x);
		if(L==R) return tr[x].siz++,void();
		int mid=L+R>>1;
		if(pos<=mid) Insert(tr[x].lc,L,mid,pos);
		else Insert(tr[x].rc,mid+1,R,pos);
		PushUp(x);
	}
	inline int Query(int x,int L,int R,int l,int r){
		if(!x) return 0;
		if(l<=L&&R<=r) return tr[x].siz;
		int mid=L+R>>1;
		if(r<=mid) return Query(tr[x].lc,L,mid,l,r);
		else if(l>mid) return Query(tr[x].rc,mid+1,R,l,r);
		else return Query(tr[x].lc,L,mid,l,r)+Query(tr[x].rc,mid+1,R,l,r);
	}
}
namespace ACAM{
	struct Node{
		int son[4],fail,t;
		vector<int> ed;
	}tr[L];

	int cnt,root;
	inline int Allc(){return ++cnt;}
	inline void Insert(string &s,int val){
		int x=root;
		for(auto c:s){
			if(!tr[x].son[c-'a']) tr[x].son[c-'a']=Allc();
			x=tr[x].son[c-'a'];
		}
		tr[x].ed.push_back(val);
	}
	inline void GetFail(){
		queue<int> q;
		for(int i:{0,1,2,3}){
			if(!tr[root].son[i]) continue ;
			tr[tr[root].son[i]].fail=root;
			q.push(tr[root].son[i]);
		}
		while(q.size()){
			int x=q.front();
			q.pop();
			tr[x].t=tr[tr[x].fail].t;
			for(int val:tr[x].ed) PSgT::Insert(tr[x].t,1,V,val);
			for(int i:{0,1,2,3}){
				if(tr[x].son[i]){
					tr[tr[x].son[i]].fail=tr[tr[x].fail].son[i];
					q.push(tr[x].son[i]);
				}else tr[x].son[i]=tr[tr[x].fail].son[i];
			}
		}
	}

	vector<int> to[L];
	int elr[L<<1],pos[L],sop[L],ecnt;
	inline void GetElr(int x){
		elr[++ecnt]=x;
		pos[x]=ecnt;
		for(int y:to[x]){
			GetElr(y);
			elr[++ecnt]=x;
		}
		sop[x]=ecnt;
	}
	int mn[L<<1][lgL+1],lg[L<<1];
	inline void InitLCA(){
		for(int i=2;i<=ecnt;i++) lg[i]=lg[i>>1]+1;
		for(int i=1;i<=ecnt;i++) mn[i][0]=pos[elr[i]];
		for(int k=1;k<=lg[ecnt];k++){
			for(int i=1;i<=ecnt-(1<<k)+1;i++){
				mn[i][k]=min(mn[i][k-1],mn[i+(1<<k-1)][k-1]);
			}
		}
	}
	inline int LCA(int x,int y){
		x=pos[x],y=pos[y];
		if(x>y) swap(x,y);
		int k=lg[y-x+1];
		return elr[min(mn[x][k],mn[y-(1<<k)+1][k])];
	}
	inline void InitTree(){
		for(int i=1;i<=cnt;i++) to[tr[i].fail].push_back(i);
		GetElr(0);
		InitLCA();
	}

	inline int Query(string s,int k){
		vector<int> p;
		int x=root;
		for(char c:s){
			p.push_back(x);
			x=tr[x].son[c-'a'];
		}
		p.push_back(x);

		int c=p.size();
		sort(p.begin(),p.end(),[](int i,int j){return pos[i]<pos[j];});
		vector<int> q(p);
		for(int &x:q) x=pos[x];
		p.erase(unique(p.begin(),p.end()),p.end());
		for(int i=1;i<c;i++) p.push_back(LCA(p[i-1],p[i]));
		sort(p.begin(),p.end(),[](int i,int j){return pos[i]<pos[j];});
		p.erase(unique(p.begin(),p.end()),p.end());
		auto Count=[&](int mid){
			int ans=0;
			for(int i=1;i<p.size();i++){
				int x=p[i],f=LCA(p[i-1],p[i]);
				int cnt=upper_bound(q.begin(),q.end(),sop[x])-lower_bound(q.begin(),q.end(),pos[x]);
				int trg=(mid+cnt-1)/cnt;
				if(trg>V) continue ;
				ans+=PSgT::Query(tr[x].t,1,V,trg,V)-PSgT::Query(tr[f].t,1,V,trg,V);
			}
			return ans;
		};

		int l=0,r=1e9;
		while(l+1<r){
			int mid=l+r>>1;
			if(Count(mid)>=k) l=mid;
			else r=mid;
		}

		return l;
	}
}

string s[N];
int val[N],n,q;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>s[i]>>val[i];

	for(int i=1;i<=n;i++) ACAM::Insert(s[i],val[i]);
	ACAM::GetFail();
	ACAM::InitTree();

	while(q--){
		string t;int k;
		cin>>t>>k;
		cout<<ACAM::Query(t,k)<<endl;
	}

	return 0;
}
```

### [JOISC 2015] AAQQZ

考虑分讨：

- 若操作区间满足 $l=r$，即没操作：直接暴力枚举回文中心暴力算长度即可。

- 若操作区间和回文中心无交：不失一般性地令操作区间在回文中心的右边。

  以 $\tt {\color{blue}853}{\color{red}212}{\color{blue}\underline{53}78}$ 为例，首先先找到原串以 $\tt{\color{red}1}$ 为回文中心的极长回文串，即 $\tt{\color{red}212}$。然后开始枚举不操作的那边，即 $\tt {\color{blue}3\rightarrow 5\rightarrow 8}$，并维护此时的操作区间，如果该数在目前操作区间中未出现，那么向右扩展到该数出现。

  如果扩展的同时出现了比当前数小的数，或是原来的区间已经有比当前数小的且没被之前枚举过的数匹配的，那么这就倒闭了，因为右边相应位置会偏小。还有就是在操作区间对称的位置的值是单调的，不单调也倒闭，原因显然。

  以上不合法条件可以简单地用桶和双指针维护。

  注意特判形如 $\tt {\color{green}927}{\color{blue}64}{\color{red}212}{\color{blue}\underline{64}}{\color{green}729}$ 的情况，即操作区间外侧还有可以匹配上的回文串。同时注意奇偶回文串的分讨。

- 若操作区间和回文中心无交：此时一定存在一种方案使得回文中心被操作区间包含，因为回文中心就是最小/大值，仍然不失一般性地令操作区间相对在回文中心的右边。

  以 $\tt {\color{blue}853}{\color{red}1}{\color{blue}53}{\color{red}1}{\color{blue}87}{\color{red}1}$ 为例，此时 $\tt\color{red} 1$ 是最小值，相应地，也就是回文中心。操作大体和上一种情况类似，在左边枚举，并扩展操作区间，如果区间中出现了比当前数小的且没被之前枚举过的数匹配的同时**不为最小值**的数，那么就倒闭了，注意操作 $\tt {\color{red}1}{\color{blue}53}{\color{red}1}$ 并不会使上面的例子倒闭。

  以上不合法条件可以简单地用桶和双指针维护。

  但是发现这样似乎漏了一些情况，考虑对于 $\tt\color{blue}53$ 来说，最优的操作区间其实是 $\tt {\color{red}1}{\color{blue}53}{\color{red}1}{\color{blue}87}{\color{red}1}$，因为后面的 $\tt \color{red}1$ 到前面了。

  所以事实上，真正的最优操作区间是在保证**对于当前段**合法的情况下尽可能向右操作的区间，这个直接 $O(n^3)$ 实现可以就迅速冲过去（指 70ms），但是题解需要时间复杂度正确，所以离线下来再在单调栈上二分，这样就是 $O(n^2\log n)$ 的。应该有聪明的 $O(n^2)$ 实现，但是我比较蠢。

  注意特判操作区间外侧还有可以匹配上的回文串的情况。

写的简直是坨⑩。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=3e3+9;

int a[N],cnt[N],o[N],n,v;
vector<array<int,2>> q[N];
inline void Work(int &ans){
	for(int i=1;i<=n;i++){
		int p=0;
		while(i+p<=n&&i-p>=1&&a[i+p]==a[i-p]) p++;
		ans=max(ans,p-1<<1|1);
		if(i+p>n||i-p<1) continue ;
		bool err=0;
		int j=i-p,k=i+p,lst=0;
		while(j>=1){
			cnt[a[j]]--;
			for(int t=lst;t<a[j];t++) err|=cnt[t];
			if(err) break ;
			if(a[j]<lst){
				if(i-j+1!=k-i+1) break ;
				while(j>=1&&k<=n&&a[j]==a[k]) j--,k++;
				ans=max(ans,k-j-1);
				break ;
			}
			lst=a[j];
			while(k<=n&&cnt[a[j]]<0){
				cnt[a[k]]++;
				err|=(a[k]<a[j]);
				k++;
			}
			err|=(cnt[a[j]]<0);
			if(err) break ;
			ans=max(ans,i-j<<1|1);
			j--;
		}
		for(int t=0;t<=v;t++) cnt[t]=0;
	}
	for(int i=1;i<=n;i++){
		int p=0;
		while(i+1+p<=n&&i-p>=1&&a[i+1+p]==a[i-p]) p++;
		ans=max(ans,p<<1);
		if(i+1+p>n||i-p<1) continue ;
		bool err=0;
		int j=i-p,k=i+p+1,lst=0;
		while(j>=1){
			cnt[a[j]]--;
			for(int t=lst;t<a[j];t++) err|=cnt[t];
			if(err) break ;
			if(a[j]<lst){
				if(i-j+1!=k-i) break ;
				while(j>=1&&k<=n&&a[j]==a[k]) j--,k++;
				ans=max(ans,k-j-1);
				break ;
			}
			lst=a[j];
			while(k<=n&&cnt[a[j]]<0){
				cnt[a[k]]++;
				err|=(a[k]<a[j]);
				k++;
			}
			err|=(cnt[a[j]]<0);
			if(err) break ;
			ans=max(ans,i-j+1<<1);
			j--;
		}
		for(int t=0;t<=v;t++) cnt[t]=0;
	}
	for(int i=1;i<=n;i++){
		int j=i-1,k=i;
		if(j<1) continue ;
		while(k<=n&&a[k]>=a[j]) cnt[a[k++]]++;
		if(k<=n){
			bool err=0;
			int mn=a[k],lst=mn+1;
			cnt[a[k++]]++;
			while(j>=1){
				cnt[a[j]]--;
				for(int t=lst;t<a[j];t++) err|=cnt[t];
				if(err) break ;
				if(a[j]<lst){
					if(k-j+1!=(i-j)*2+cnt[mn]) break ;
					while(k<=n&&a[k]==mn) k++;
					while(j>=1&&k<=n){
						if(a[j]==a[k]) j--,k++;
						else break ;
					}
					ans=max(ans,k-j-1);
					break ;
				}
				lst=a[j];
				while(k<=n&&cnt[a[j]]<0){
					cnt[a[k]]++;
					err|=(a[k]<a[j]&&a[k]!=mn);
					k++;
				}
				err|=(cnt[a[j]]<0);
				if(err) break ;
				// int cc=0;
				// for(int t=k;t<=n;t++){
				// 	if(a[t]<a[j]&&a[t]!=mn) break ;
				// 	cc+=(a[t]==mn);
				// }
				// ans=max(ans,(i-j<<1)+cnt[mn]+cc);
				q[k].push_back({(i-j<<1)+cnt[mn],a[j]});
				j--;
			}
			for(int t=i;t<=n;t++) o[t]=o[t-1]+(a[t]==mn);
			vector<int> stk,w;
			for(int t=n;t>=i;t--){
				if(a[t]!=mn){
					while(stk.size()&&w.back()>=a[t]) stk.pop_back(),w.pop_back();
					stk.push_back(t),w.push_back(a[t]);
				}
				for(auto d:q[t]){
					int p=lower_bound(w.begin(),w.end(),d[1])-w.begin()-1;
					ans=max(ans,d[0]+o[p<0?n:stk[p]-1]-o[t-1]);
				}
				q[t].clear();
			}
		}
		for(int t=0;t<=v;t++) cnt[t]=o[t]=0;
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);

	cin>>n>>v;
	for(int i=1;i<=n;i++) cin>>a[i];

	int ans=0;
	Work(ans);
	reverse(a+1,a+n+1);
	for(int i=1;i<=n;i++) a[i]=v-a[i]+1;
	Work(ans);
	for(int i=1;i<=v;i++) ans=max(ans,(int)count(a+1,a+n+1,i));

	cout<<ans<<endl;

	return 0;
}
```

### [JOISC 2018] 修行 / Asceticism

写一种不太一样的做法。

考虑对 $>$ 容斥，变成 $\leq$ 和 $?$，求出钦定 $i$ 个 $\leq$ 的答案。考察由 $<$ 和 $\leq$ 连接的段为连续段，其内部的顺序相对固定，因此可看作一个集合，故答案为：

$$\begin{eqnarray}\displaystyle \left \langle \begin{matrix}n\\m\end{matrix} \right \rangle =\sum_{i=0}^{m} (-1)^{m-i} \binom{n-i-1}{m-i} \begin{Bmatrix}n\\i+1\end{Bmatrix}(i+1)!
\\=\displaystyle \sum_{i=0}^{m} (-1)^{m-i} \binom{n-i-1}{m-i} \sum_{j=0}^{i+1}(-1)^{i-j+1}j^n\binom{i+1}{j}
\\=\displaystyle \sum_{i=0}^{m} \sum_{j=0}^{i+1}(-1)^{m-j+1}j^n\binom{i+1}{j}\binom{n-i-1}{n-m-1}
\\=\displaystyle \sum_{j=0}^{m+1}(-1)^{m-j+1}j^n\binom{n+1}{n-m+j}
\\=\displaystyle \sum_{i=0}^{m+1}(-1)^{i}(m-i+1)^n\binom{n+1}{i}\end{eqnarray}$$

另一种式子题解有。

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll=long long;
const int N=1e5+9;
const int mod=1e9+7;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
#define Inv(x) QPow(x,mod-2)

int fac[N],ifac[N];
inline void Init(int lim){
	fac[0]=1;
	for(int i=1;i<=lim;i++) fac[i]=Mul(fac[i-1],i);
	ifac[lim]=Inv(fac[lim]);
	for(int i=lim-1;~i;i--) ifac[i]=Mul(ifac[i+1],i+1);
}
inline int C(int n,int m){
	if(m<0||m>n) return 0;
	else return Mul(fac[n],Mul(ifac[m],ifac[n-m]));
}

int n,k;

signed main(){
	cin>>n>>k,k--;

	int res=0;
	Init(n+1);
	for(int i=0;i<=k+1;i++){
		AddAs(res,Mul(QPow(mod-1,i),Mul(QPow(k-i+1,n),C(n+1,i))));
	}
	
	cout<<res<<endl;

	return 0;
}
```

### [ZJOI2018] 历史

如果节点 $u$ 取到的是 $2(\sum s_i-\max s_i)$，则称 $u$ 到取到 $\max s_i$ 的那个子树的边为重边，否则为轻边。由于每跳一次轻边 $s_i$ 至少翻一倍，所以到根路径的 access 跳过的轻边个数是 $O(\log \sum a_i)=O(\log V)$ 的。对于每次修改，连向 $x_i$ 的重边修改后只会更重，所以需要修改的只有轻边，写个 LCT 暴力维护即可。时间复杂度 $O(n\log V)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=4e5+9;

ll a[N];
int typ[N],n,q;

struct Node{
	int son[2],fa,typ;
	ll siz,vsiz;
}tr[N];

inline void PushUp(int x){tr[x].siz=a[x]+tr[tr[x].son[0]].siz+tr[tr[x].son[1]].siz+tr[x].vsiz;}
inline bool IsRoot(int x){return x!=tr[tr[x].fa].son[0]&&x!=tr[tr[x].fa].son[1];}
inline bool Id(int x){return x==tr[tr[x].fa].son[1];}

inline void Rotate(int x){
	int y=tr[x].fa,z=tr[y].fa,f=Id(x);
	if(!IsRoot(y)) tr[z].son[Id(y)]=x;
	tr[y].son[f]=tr[x].son[!f],tr[tr[x].son[!f]].fa=y,PushUp(y);
	tr[x].son[!f]=y,tr[y].fa=x,PushUp(x);
	tr[x].fa=z;
}
inline void Splay(int x){
	for(int y=tr[x].fa;!IsRoot(x);Rotate(x),y=tr[x].fa){
		if(!IsRoot(y)) Rotate(Id(x)==Id(y)?y:x);
	}
}

ll ans;
vector<int> e[N];
inline void DFS(int x,int fa){
	tr[x].vsiz=0;
	ll mx=a[x];int hson=0;
	for(int y:e[x]){
		if(y==fa) continue ;
		tr[y].fa=x;
		DFS(y,x);
		tr[x].vsiz+=tr[y].siz;
		if(tr[y].siz>mx) mx=tr[y].siz,hson=y;
	}
	tr[x].siz=tr[x].vsiz+a[x];
	if(mx*2>tr[x].siz){
		ans+=(tr[x].siz-mx)*2;
		if(hson){
			tr[x].vsiz-=tr[hson].siz;
			tr[x].son[1]=hson;
			typ[x]=0;
		}else typ[x]=1;
	}else ans+=tr[x].siz-1,typ[x]=2;
}
inline void Access(int x,int k){
	int p=0;
	while(x){
		Splay(x);
		
		ll sum=tr[x].siz-tr[tr[x].son[0]].siz;
		if(typ[x]==0) ans-=(sum-tr[tr[x].son[1]].siz)*2;
		else if(typ[x]==1) ans-=(sum-a[x])*2;
		else if(typ[x]==2) ans-=sum-1;
		
		if(p) tr[x].vsiz+=k;
		else a[x]+=k;
		PushUp(x);

		sum=tr[x].siz-tr[tr[x].son[0]].siz;
		if(2*tr[p].siz>sum){
			tr[x].vsiz+=tr[tr[x].son[1]].siz;
			tr[x].son[1]=p;
			tr[x].vsiz-=tr[tr[x].son[1]].siz;
		}
		if(2*tr[tr[x].son[1]].siz>sum) ans+=(sum-tr[tr[x].son[1]].siz)*2,typ[x]=0;
		else{
			if(tr[x].son[1]){
				tr[x].vsiz+=tr[tr[x].son[1]].siz;
				tr[x].son[1]=0;
			}
			if(2*a[x]>sum) ans+=(sum-a[x])*2,typ[x]=1;
			else ans+=sum-1,typ[x]=2;
		}

		p=x,x=tr[x].fa;
	}
}

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);

	cin>>n>>q;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1,u,v;i<n;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}

	DFS(1,-1);
	cout<<ans<<endl;
	while(q--){
		int x,k;
		cin>>x>>k;
		Access(x,k);
		cout<<ans<<endl;
	}

	return 0;
}
```

### [CCO 2020] Shopping Plans

超级超级钢琴。

先考虑 $m=1$ 怎么做，设 $(x,y,z)$ 三元组表示 $[1,x]$ 全选，第 $x+1$ 位在 $y$ 上，第 $x+1$ 位不能移到 $z$ 后面。这样相当于从后向前逐位确定取值，同时将状态简化到可以 $O(1)$ 记录的形式，可以超级钢琴。

再考虑 $x_i=y_i=1$ 怎么做，依然考虑逐行确定，但此处后继状态是 $O(n)$ 的，考虑换成兄弟表示法，由于每次开新的一行一定是选次小值最小值之差最小的转移最优，所以将各行按次小值最小值之差排序，依次尝试转移。

最后就是内层用 $m=1$ 算，外层用 $x_i=y_i=1$ 做，时间复杂度 $O((n+k)\log n)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e5+9;

ll dlt[N];
int a[N],c[N],n,m,k;

struct KS{
	int llim,rlim;
	vector<ll> v,res;
	priority_queue<array<ll,4>> q;
	inline void Init(){
		ll sum=0;
		sort(v.begin(),v.end());
		rlim=min(rlim,signed(v.size()));
		if(llim>v.size()) return ;
		for(int i=0;i<llim;i++) sum+=v[i];
		q.push({-sum,llim-1,llim-1,ll(v.size())});
	}
	inline void Insert(int x){v.push_back(x);}
	inline bool Extend(int i){
		while(q.size()&&res.size()<i){
			auto t=q.top();
			q.pop();
			res.push_back(-t[0]);
			if(t[1]==t[2]&&t[3]==v.size()&&t[2]+1<rlim){
				q.push({-(-t[0]+v[t[1]+1]),t[1]+1,t[2]+1,t[3]});
			}
			if(~t[2]&&t[2]+1<t[3]){
				q.push({-(-t[0]-v[t[2]]+v[t[2]+1]),t[1],t[2]+1,t[3]});
			}
			if(t[1]>0&&t[1]<t[2]){
				q.push({-(-t[0]-v[t[1]-1]+v[t[1]]),t[1]-1,t[1],t[2]});
			}
		}
		return res.size()>=i;
	}
	inline ll operator [](int x){return res[x];}
}p[N];

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m>>k;
	for(int i=1;i<=n;i++) cin>>a[i]>>c[i],p[a[i]].Insert(c[i]);
	for(int i=1;i<=m;i++) cin>>p[i].llim>>p[i].rlim,p[i].Init();

	ll sum=0;
	vector<int> id;
	for(int i=1;i<=m;i++){
		if(!p[i].Extend(1)){
			while(k--) cout<<-1<<endl;
			return 0;
		}
		sum+=p[i][0];
		if(p[i].Extend(2)){
			id.push_back(i);
			dlt[i]=p[i][1]-p[i][0];
		}
	}
	sort(id.begin(),id.end(),[](int i,int j){return dlt[i]<dlt[j];});

	priority_queue<array<ll,4>> q;
	q.push({-sum,-1,0});
	while(q.size()&&k--){
		auto t=q.top();
		q.pop();
		cout<<-t[0]<<endl;

		if(~t[1]&&p[id[t[1]]].Extend(t[2]+2)){
			q.push({-(-t[0]-p[id[t[1]]][t[2]]+p[id[t[1]]][t[2]+1]),t[1],t[2]+1});
		}
		if(t[1]+1<id.size()){
			q.push({-(-t[0]-p[id[t[1]+1]][0]+p[id[t[1]+1]][1]),t[1]+1,1});
		}
		if(t[1]+1<id.size()&&t[2]==1){
			q.push({-(-t[0]-p[id[t[1]]][1]+p[id[t[1]]][0]-p[id[t[1]+1]][0]+p[id[t[1]+1]][1]),t[1]+1,1});
		}
	}
	while(k-->0) cout<<-1<<endl;

	return 0;
}
```

### [PA 2021] Od deski do deski

首先合法区间一定是 $\tt A\ldots AB\ldots BC\ldots C$ 状物，直接对这个形态计数不是很有前途，因此考虑逐位确定。

设 $f_{i,j,0/1}$ 表示当前考虑到第 $i$ 位，到目前共有 $j$ 种可以作为段首的颜色，以及当前是/不是段尾。转移是简单的，直接枚举当前位状态即可，时间复杂度 $O(n^2)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=3e3+9;
const int mod=1e9+7;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
#define Inv(x) QPow(x,mod-2)

int f[N][N][2],n,m;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	
	f[1][1][0]=m;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=min(i,m);j++){
			AddAs(f[i+1][j][1],Mul(f[i][j][0],j));
			AddAs(f[i+1][j][0],Mul(f[i][j][0],m-j));
			AddAs(f[i+1][j][1],Mul(f[i][j][1],j));
			AddAs(f[i+1][j+1][0],Mul(f[i][j][1],m-j));
		}
	}

	int ans=0;
	for(int j=1;j<=min(n,m);j++) AddAs(ans,f[n][j][1]);

	cout<<ans<<endl;

	return 0;
}
```

### [CCC 2024 S5] Chocolate Bar Partition

嘟？！

首先先把每个树减去平均数，这样要求就是每块和为 $0$。然后注意到 $0+0=0$，所以对于一个从左到右扫的过程，只要判断当前第一二行的前缀和之和是否为 $0$ 即可，前面的分段就不重要了。设 $f_{i,0/1/2/3}$ 表示当前处理到第 $i$ 位，第一/二行的状态分别是段尾/非段尾，令 $s_{0/1,i}$ 表示第一/二行的前缀和。

$f_{1,3}=\min f_{i-1,0/1/2/3}+1$ 和当 $s_{0,i}+s_{1,i}=0$ 时 $f_{0}=\min f_{i,1/2/3}+1$ 这两种转移是好理解的，现考虑 $f_{i,1/2}$ 的转移，以 $f_{i,1}$ 为例，令 $j$ 为比 $i$ 小且满足 $s_{0,j}=s_{0,i}$ 或 $s_{1,j}+s_{0,i}=0$ 的最大值：

-   若 $s_{0,j}=s_{0,i}$ 且 $s_{1,j}+s_{0,i}=0$，那么显然 $j$ 处第一第二行都可以取到段尾，$f_{i,1}\leftarrow f_{j,0}+1$。
-   若仅有 $s_{0,j}=s_{0,i}$，那么 $j$ 处第一行是可以取到段尾的，或者 $j$ 处第一行和 $i$ 处第二行联通，反正在 $j$ 处第一行有一个分割，$f_{i,1}\leftarrow \max(f_{j,1},f_{j,3})+1$。
-   若仅有 $s_{i,j}+s_{0,i}=0$，那么 $j$ 处第二行和 $i$ 处第一行可以构成连通块，或者两行单独成块，$f_{i,1}\leftarrow \max(f_{j,2},f_{j,3})+1$。

$f_{i,2}$ 有类似的转移。所以只要用 map 找到符合条件的 $j$ 即可，时间复杂度 $O(n\log n)$，可以优化到线性。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e5+9;

int f[N][4],n;
ll a[2][N],s[2][N];

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int k:{0,1}) for(int i=1;i<=n;i++) cin>>a[k][i];

	ll sum=0;
	for(int k:{0,1}) for(int i=1;i<=n;i++) sum+=a[k][i];
	for(int k:{0,1}){
		for(int i=1;i<=n;i++){
			a[k][i]=2*n*a[k][i]-sum;
			s[k][i]=s[k][i-1]+a[k][i];
		}
	}

	map<ll,int> occ[2];
	occ[0][0]=occ[1][0]=0;
	memset(f,-0x3f,sizeof f);
	f[0][0]=0;
	for(int i=1;i<=n;i++){
		f[i][3]=*max_element(f[i-1],f[i-1]+4);
		for(int k:{0,1}){
			int p=occ[k].count(s[k][i])?occ[k][s[k][i]]:-1;
			int q=occ[k^1].count(-s[k][i])?occ[k^1][-s[k][i]]:-1;
			if(!~p&&!~q) continue ;
			int j=max(p,q);
			if(q<j) f[i][1<<k]=max(f[j][1<<k],f[j][3])+1;
			else if(p<j) f[i][1<<k]=max(f[j][1<<!k],f[j][3])+1;
			else f[i][1<<k]=f[j][0]+1;
		}
		if(s[0][i]+s[1][i]==0) f[i][0]=*max_element(f[i],f[i]+4)+1;
		occ[0][s[0][i]]=occ[1][s[1][i]]=i;
	}

	cout<<f[n][0]<<endl;

	return 0;
}
```

### [PA 2024] Desant 3

首先操作可以看成是 $w_{a_i}>w_{b_i}$ 才交换，同时我们认为两个相同的数可交换可不交换，由于 $n=35$ 不太能是多项式算法（把那个 $O(N^{13})$ 的 DP 题先放一边），考虑搜剪，具体地，令所有 $w_i$ 最开始都是 $\tt ?$，之后再填：

-   若 $w_{a_i}$ 和 $w_{b_i}$ 均不是 $\tt ?$：直接按题意交换即可。
-   若只有 $w_{a_i}$ 不是 $\tt ?$：由于 $w_{a_i}>w_{b_i}$ 才必须交换，所以若 $w_{b_i}=\mathtt{1}$ 一定可以不交换，$w_{b_i}=\mathtt{0}$ 一定可以交换。
-   若只有 $w_{b_i}$ 不是 $\tt ?$：类似地，若 $w_{a_i}=\mathtt{0}$ 一定可以不交换，$w_{a_i}=\mathtt{1}$ 一定可以交换。
-   若 $w_{a_i}$ 和 $w_{b_i}$ 均是 $\tt ?$：这种情况下 $w_{a_i}=\mathtt{0},w_{b_i}=\mathtt{1}$ 和 $w_{a_i}=\mathtt{1},w_{b_i}=\mathtt{0}$ 是对称的，因此只需要枚举 $w_{a_i}=w_{b_i}$ 的情况。

综上，会产生分支的地方就是 $w_{a_i}=w_{b_i}=\mathtt{?}$，一次消掉两个，总状态数就是 $O(2^{\frac n2})$ 的，时间复杂度 $O((m+n^2)2^{\frac n2})$。

```cpp
#include<bits/stdc++.h>

using namespace std;

const int N=3e2+9;
const int M=1e3+9;

int a[M],b[M],p[N],ans[N],n,m;
inline void DFS(int d){
	if(d>m){
		int cnt=count(p+1,p+n+1,1);
		for(int i=1;i<=n;i++){
			for(int j=i,cur=0;j<=n;j++){
				if(!p[j]) break ;
				if(p[j]==1) cur++;
				if(cur==cnt) ans[j-i+1]^=1;
			}
		}
		return ;
	}
	if(~p[a[d]]&&~p[b[d]]){
		if(p[a[d]]>p[b[d]]){
			swap(p[a[d]],p[b[d]]);
			DFS(d+1);
			swap(p[a[d]],p[b[d]]);
		}else DFS(d+1);
	}else if(~p[b[d]]){
		if(!p[b[d]]){
			swap(p[a[d]],p[b[d]]);
			DFS(d+1);
			swap(p[a[d]],p[b[d]]);
		}else DFS(d+1);
	}else if(~p[a[d]]){
		if(p[a[d]]){
			swap(p[a[d]],p[b[d]]);
			DFS(d+1);
			swap(p[a[d]],p[b[d]]);
		}else DFS(d+1);
	}else{
		p[a[d]]=p[b[d]]=0;
		DFS(d+1);
		p[a[d]]=p[b[d]]=1;
		DFS(d+1);
		p[a[d]]=p[b[d]]=-1;
	}
}

signed main(){
	cin>>n>>m;
	for(int i=1;i<=m;i++) cin>>a[i]>>b[i];

	fill(p+1,p+n+1,-1);
	DFS(1);

	for(int i=1;i<=n;i++) cout<<ans[i]<<' ';cout<<endl;

	return 0;
}
```

### [PA 2024] Kraniki

呃呃其实题面可以改成等概率选取未覆盖的水龙头然后要求选手先进行「王の忽略」的转化的。

然后，对于一个水龙头 $i$，假设有 $t_i$ 个水龙头可以直接或间接地流向 $i$（包含 $i$ 本身），那么 $i$ 自身要打开的概率就是 $\dfrac{1}{t_i}$，由期望的线性性可知答案就是 $\displaystyle \sum_{i=1}^n \dfrac{1}{t_i}$。

现在的问题是如何求解 $t_i$。考虑从下往上找可以流向 $i$ 的线段，同时维护现在整个 $i$ 及可以流向 $i$ 的线段的边界，则在边界上方且与边界在横轴上投影有交的线段是可以流向 $i$ 的，除了直接包含整个边界的，这种会直接加一个盖子把它封上。

因此，考虑分别维护出 $i$ 的左边界和右边界，以及第一个完全覆盖的线段 $dom_i$。称与 $i$ 在左侧有交且不构成包含关系的最低线段为 $i$ 的左父亲，右父亲同理，那么，整个左边界就是 $i$ 到 $dom_i$ 为止的左祖先，右边界就是 $i$ 到 $dom_i$ 为止的右祖先，其中的线段个数则可以通过二维数点和倍增维护。而 $dom_i$ 则可以看成是由左父亲和右父亲到 $i$ 构成的 DAG 上对 $i$ 的支配点，直接在支配树上找左父亲右父亲 LCA 即可。

```cpp
#include<bits/stdc++.h>

#define endl '\n'
using namespace std;

using ll=long long;
const int N=5e5+9;
const int mod=1e9+7;
const int lgN=2e1+9;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
#define Inv(x) QPow(x,mod-2)

namespace Chth{
	struct Seg{
		int l,r,v;
		Seg(){};
		Seg(int _l,int _r,int _v){l=_l,r=_r,v=_v;}
		bool friend operator <(const Seg s,const Seg t){return s.l<t.l;}
	};
	set<Seg> s;
	inline auto Split(int p){
		auto it=s.lower_bound(Seg(p,0,0));
		if(it!=s.end()&&it->l==p) return it;
		it--;
		int l=it->l,r=it->r,v=it->v;
		s.erase(it);
		s.insert(Seg(l,p-1,v));
		return s.insert(Seg(p,r,v)).first;
	}
	inline void Assign(int l,int r,int v){
		auto rit=Split(r+1),lit=Split(l);
		s.erase(lit,rit);
		s.insert(Seg(l,r,v));
	}
	inline int Query(int p){return (--s.lower_bound(Seg(p+1,0,0)))->v;}
}
namespace Fenw{
	int tr[N<<1],lim;
	inline void Init(int _lim){lim=_lim;}
	inline void Modify(int x,int k){while(x<=lim) tr[x]+=k,x+=x&-x;}
	inline int Query(int x){int sum=0;while(x) sum+=tr[x],x&=x-1;return sum;}
	inline int Query(int l,int r){return Query(r)-Query(l-1);}
}

int lp[N],rp[N],n;
vector<tuple<int,int,int&>> opr[N];

int dep[N],lfa[N][lgN],rfa[N][lgN],dom[N][lgN],lw[N][lgN],rw[N][lgN];
inline int LCA(int x,int y){
	if(dep[x]<dep[y]) swap(x,y);
	for(int k=lgN-1;~k;k--) if(dep[dom[x][k]]>=dep[y]) x=dom[x][k];
	if(x==y) return x;
	for(int k=lgN-1;~k;k--) if(dom[x][k]!=dom[y][k]) x=dom[x][k],y=dom[y][k];
	return dom[x][0];
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=n;i>=1;i--) cin>>lp[i]>>rp[i];

	lp[0]=0,rp[0]=2*n+1;
	Chth::s.insert(Chth::Seg(0,2*n+1,0));
	for(int i=1;i<=n;i++){
		lfa[i][0]=Chth::Query(lp[i]);
		rfa[i][0]=Chth::Query(rp[i]);
		Chth::Assign(lp[i],rp[i],i);
		opr[i].push_back({lp[i]-1,1,lw[i][0]});
		opr[lfa[i][0]].push_back({lp[i]-1,-1,lw[i][0]});
		opr[i].push_back({rp[i],1,rw[i][0]});
		opr[rfa[i][0]].push_back({rp[i],-1,rw[i][0]});
		dom[i][0]=LCA(lfa[i][0],rfa[i][0]);
		dep[i]=dep[dom[i][0]]+1;
		for(int k=1;k<lgN;k++){
			dom[i][k]=dom[dom[i][k-1]][k-1];
			lfa[i][k]=lfa[lfa[i][k-1]][k-1];
			rfa[i][k]=rfa[rfa[i][k-1]][k-1];
		}
	}
	Fenw::Init(n<<1|1);
	for(int i=1;i<=n;i++){
		Fenw::Modify(rp[i],1);
		for(auto &t:opr[i]) get<2>(t)+=Fenw::Query(get<0>(t))*get<1>(t);
	}
	for(int i=1;i<=n;i++){
		for(int k=1;k<lgN;k++){
			lw[i][k]=lw[i][k-1]+lw[lfa[i][k-1]][k-1];
			rw[i][k]=rw[i][k-1]+rw[rfa[i][k-1]][k-1];
		}
	}

	int ans=0;
	for(int i=1;i<=n;i++){
		int sum=0,lx=i,rx=i;
		for(int k=lgN-1;~k;k--){
			if(lfa[lx][k]>=dom[i][0]) sum-=lw[lx][k],lx=lfa[lx][k];
			if(rfa[rx][k]>=dom[i][0]) sum+=rw[rx][k],rx=rfa[rx][k];
		}
		AddAs(ans,Inv(sum));
	}

	cout<<ans<<endl;

	return 0;
}
```

### [PA 2024] Żarówki

【数据删除】题。

首先化用 [AGC004] F - Namori 的套路，尝试对各连通块进行黑白染色，并对黑点灯泡状态取反，转化为推箱子问题：

-   若该连通块中存在奇环，那么奇环上那条边可以凭空多/少两个箱子，所以所有可达的状态就是和初始箱子数奇偶相同的状态，即 $\displaystyle \sum_{i=0}^m\dbinom mi[i\bmod 2=k]=2^{m-1}$ 中状态，其中 $m$ 为连通块大小。
-   该图为二分图，那么箱子数固定，状态数为 $\dbinom {b+w}{b}$，其中 $b,w$ 分别为连通块中开/关灯泡个数。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=2e5+9;
const int mod=1e9+7;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
#define Inv(x) QPow(x,mod-2)

int fac[N],ifac[N];
inline void Init(int lim){
	fac[0]=1;
	for(int i=1;i<=lim;i++) fac[i]=Mul(fac[i-1],i);
	ifac[lim]=Inv(fac[lim]);
	for(int i=lim-1;~i;i--) ifac[i]=Mul(ifac[i+1],i+1);
}
inline int C(int n,int m){
	if(m<0||m>n) return 0;
	else return Mul(fac[n],Mul(ifac[m],ifac[n-m]));
}

int a[N],c[N],n,m;
vector<int> e[N];
inline int DFS(int x,vector<int> &v){
	bool flag=0;
	v.push_back(x);
	for(int y:e[x]){
		if(!c[y]){
			c[y]=-c[x];
			flag|=DFS(y,v);
		}else if(c[y]==c[x]) flag|=1;
	}
	return flag;
}

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		e[u].push_back(v);
		e[v].push_back(u);
	}

	Init(n);
	int res=1;
	for(int i=1;i<=n;i++){
		if(c[i]) continue ;
		vector<int> v;
		c[i]=1;
		if(DFS(i,v)) MulAs(res,QPow(2,v.size()-1));
		else{
			int cnt=0;
			for(int x:v) cnt+=a[x]^(c[x]>0);
			MulAs(res,C(v.size(),cnt));
		}
	}

	cout<<res<<endl;

	return 0;
}
```

### [COTS 2024]  Tikvani

遇到条件不要先刻画，先想想能不能嗯做。

考虑找出原图上所有简单的瓜子（？）即从某个根随便钦定一颗根向树，然后对于非树边找到瓜子。可以证明的是，所有非简单的瓜子可以由一些简单的瓜子拼出来，证明考虑类比无向图路径异或和。那么限制就是瓜子上的边异或和为零，将所有限制插进线性基中，设有 $k$ 组基向量，这 $k$ 条基向量就是最基本的限制，消元之后每个向量随便钦定一条边兜底，所以答案就是 $2^{m-k}$。

```cpp
#include<bits/stdc++.h>

using namespace std;

using ll=long long;
const int N=4e2+9;
const int mod=1e9+7;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
#define Inv(x) QPow(x,mod-2)

struct Basis{
	bitset<N> b[N];
	inline bool Insert(bitset<N> x){
		for(int i=N-1;~i;i--){
			if(!x[i]) continue ;
			if(b[i].none()){
				b[i]=x;
				return 1;
			}else x^=b[i];
		}
		return 0;
	}
}b;

bitset<N> pre[N];
int vis[N],n,m,cnt;
vector<array<int,2>> e[N];
inline void DFS(int x){
	vis[x]=1;
	for(auto t:e[x]){
		if(!vis[t[0]]){
			pre[t[0]]=bitset<N>(pre[x]).set(t[1]);
			DFS(t[0]);
		}else cnt+=b.Insert(bitset<N>(pre[x]^pre[t[0]]).set(t[1]));
	}
}

signed main(){
	cin>>n>>m;
	for(int i=1,u,v;i<=m;i++){
		cin>>u>>v;
		e[u].push_back({v,i});
	}

	for(int i=1;i<=n;i++){
		DFS(i);
		for(int j=1;j<=n;j++) vis[j]=0;
	}

	cout<<QPow(2,m-cnt)<<endl;

	return 0;
}
```

### [HBCPC2024] Points on the Number Axis B

由于期望的线性性，考虑对每个 $x_i$ 算出其贡献。

令 $f_{i,j}$ 表示当前点左边共有 $i$ 个点，右边共有 $j$ 个点，有转移 $f_{i,j}=\dfrac {(i-1)+\frac 12}{i+j}f_{i-1,j}+\dfrac {(j-1)+\frac 12}{i+j}f_{i,j-1}$。

然后发现怎么转移系数都是 $\displaystyle \frac{\prod_{k=1}^i(k-\frac 12)\prod_{k=1}^j(k-\frac 12)}{(i+j)!}$，总转移方案数是 $\dbinom{i+j}{i}$，预处理乘在一起就是答案了。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=1e6+9;
const int mod=998244353;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

int fac[N],ifac[N];
inline void Init(int lim){
	fac[0]=1;
	for(int i=1;i<=lim;i++) fac[i]=Mul(fac[i-1],i);
	ifac[lim]=Inv(fac[lim]);
	for(int i=lim-1;~i;i--) ifac[i]=Mul(ifac[i+1],i+1);
}
inline int C(int n,int m){return Mul(fac[n],Mul(ifac[m],ifac[n-m]));}

int x[N],n;

signed main(){
	ios::sync_with_stdio(0);
	cin.tie(0),cout.tie(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>x[i];

	Init(n);

	int inv2=Inv(2),ans=0;
	vector<int> w(n,1);
	for(int i=1;i<n;i++) w[i]=Mul(w[i-1],Sub(i,inv2));
	for(int i=1;i<=n;i++){
		AddAs(ans,Mul(Mul(Mul(ifac[n-1],C(n-1,i-1)),Mul(w[i-1],w[n-i])),x[i]));
	}

	cout<<ans<<endl;

	return 0;
}
```

### [BalticOI 2024] Jobs

对于每个点维护 $f_i$ 表示其至少投入 $f_i$ 才能赚钱，特别地，不能赚钱就是 $+\infty$，那么对于某个根 $u$，优先选 $f_v$ 较小的儿子 $v$，选完了之后直接扩展 $v$ 的儿子，如果当前所有 $f_v$ 均高于手上有的资产就抬高 $f_u$。

直接做是 $O(n^2\log n)$ 的，考虑优化这一过程。发现从 $u$ 扩展 $v$ 子树的过程和 $v$ 扩展自己子树的过程是相同的，因此考虑让 $u$ 扩展 $v$ 的时候直接扩展 $v$ 已经扩展的所有子树，用可并堆维护所有仍未扩展的子树即可，时间复杂度 $O(n\log n)$。

```cpp
#include<bits/stdc++.h>

using namespace std;

using bint=__int128;
using ll=long long;
const int N=1e5+9;

int n;
ll x[N],y[N];

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];

	bint lx=0,tx=0,ty=0;
	for(int i=1;i<n;i++){
		bint _x=x[i]-x[n],_y=y[i]-y[n];
		if(_y<0) _y=-_y,_x=-_x;
		while(ty){
			ll tmp=_y/ty;
			_y-=tmp*ty;
			_x-=tmp*tx;
			swap(_y,ty),swap(_x,tx);
		}
		lx=__gcd(lx,abs(tx));
		swap(_y,ty),swap(_x,tx);
	}

	if(!lx||!ty) cout<<-1<<endl;
	else cout<<ll(lx*ty)<<endl;

	return 0;
}
```

### [BalticOI 2024] Portal

对于任意一对点 $(x_1,y_1)$ 和 $(x_2,y_2)$，题目要求就是从任意一个点出发，增加 $[x_1-x_2,y_1-y_2]$ 后的点和原来的点颜色相同。

由于这是在平面上， 考虑找出一对和原来所有向量等价的基向量。

对于一对向量，重复辗转相除后可以得到一对形如 $[a,0]$ 和 $[b,c]$ 的向量，这对向量和原来那对等价。当引入第三个向量时，继续和 $[b,c]$ 做辗转相除，又会得到 $[a',0]$ 和 $[b',c']$，而 $[a,0]$ 和 $[a',0]$ 可以合并成 $[\gcd(a,a'),0]$。至此已经可以把之前所有向量等价为两个相对独立的向量，不难发现，答案就是 $|ac|$。

```cpp
#include<bits/stdc++.h>

using namespace std;

using bint=__int128;
using ll=long long;
const int N=1e5+9;

int n;
ll x[N],y[N];

signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>x[i]>>y[i];

	bint lx=0,tx=0,ty=0;
	for(int i=1;i<n;i++){
		bint _x=x[i]-x[n],_y=y[i]-y[n];
		if(_y<0) _y=-_y,_x=-_x;
		while(ty){
			ll tmp=_y/ty;
			_y-=tmp*ty;
			_x-=tmp*tx;
			swap(_y,ty),swap(_x,tx);
		}
		lx=__gcd(lx,tx>0?tx:-tx);
		swap(_y,ty),swap(_x,tx);
	}

	if(!lx||!ty) cout<<-1<<endl;
	else cout<<ll(lx*ty)<<endl;

	return 0;
}
```

### [BalticOI 2024] Wall

首先分层，然后拆贡献，变成区间长度扣掉所有墙。对于左端点或右端点，可以使用线段树维护每个下标作为左右端点的方案数，维护的操作有区间乘和区间清空。对于中间的墙则可以直接记录每种类型（0/0，0/1 和 1/1）的贡献。注意每个 0/0 和 1/1 一定会有 $2$ 的贡献。

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
using ll=long long;
const int N=5e5+9;
const int mod=1e9+7;

inline void AddAs(int &x,int y){if((x+=y)>=mod) x-=mod;}
inline void SubAs(int &x,int y){if((x-=y)<0) x+=mod;}
inline void MulAs(int &x,int y){x=1ll*x*y%mod;}
inline int Add(int x,int y){if((x+=y)>=mod) x-=mod;return x;}
inline int Sub(int x,int y){if((x-=y)<0) x+=mod;return x;}
inline int Mul(int x,int y){return 1ll*x*y%mod;}
inline int QPow(int x,int y){
	int res=1;
	while(y){
		if(y&1) MulAs(res,x);
		MulAs(x,x);
		y>>=1;
	}
	return res;
}
inline int Inv(int x){return QPow(x,mod-2);}

int a[N],b[N],n;

struct Node{
	int l,r,dat,tag;
}tr[N<<2];
inline void PushUp(int x){tr[x].dat=Add(tr[x<<1].dat,tr[x<<1|1].dat);}
inline void Push(int x,int k){MulAs(tr[x].dat,k),MulAs(tr[x].tag,k);}
inline void PushDown(int x){if(tr[x].tag!=1) Push(x<<1,tr[x].tag),Push(x<<1|1,tr[x].tag),tr[x].tag=1;}
inline void Build(int x,int l,int r){
	tr[x].l=l,tr[x].r=r,tr[x].dat=0,tr[x].tag=1;
	if(tr[x].l==tr[x].r) return ;
	int mid=tr[x].l+tr[x].r>>1;
	Build(x<<1,l,mid),Build(x<<1|1,mid+1,r);
	PushUp(x);
}
inline void Set(int x,int pos,int k){
	if(tr[x].l==tr[x].r) return tr[x].dat=Mul(tr[x].tag,k),void();
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1;
	if(pos<=mid) Set(x<<1,pos,k);
	else Set(x<<1|1,pos,k);
	PushUp(x);
}
inline void Modify(int x,int l,int r,int k){
	if(l<=tr[x].l&&tr[x].r<=r) return Push(x,k);
	PushDown(x);
	int mid=tr[x].l+tr[x].r>>1;
	if(l<=mid) Modify(x<<1,l,r,k);
	if(r>mid) Modify(x<<1|1,l,r,k);
	PushUp(x);
}

vector<array<int,2>> op[N<<1];

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i];
	for(int i=1;i<=n;i++) cin>>b[i];

	vector<int> val={INT_MAX,0};
	for(int i=1;i<=n;i++) if(a[i]>b[i]) swap(a[i],b[i]);
	for(int i=1;i<=n;i++) val.insert(val.end(),{a[i],b[i]});
	sort(val.begin(),val.end(),greater<int>());
	val.erase(unique(val.begin(),val.end()),val.end());
	for(int i=1;i<=n;i++){
		int p=lower_bound(val.begin(),val.end(),b[i],greater<int>())-val.begin();
		int q=lower_bound(val.begin(),val.end(),a[i],greater<int>())-val.begin();
		op[p].push_back({i,0});
		op[q].push_back({i,1});
	}

	int ans=0,inv=Inv(2),cntb=n,cnts=0,cntt=0;
	Build(1,1,n);
	for(int i=1;i+1<val.size();i++){
		for(auto t:op[i]){
			int j=t[0];
			if(!t[1]){
				Set(1,j,j-1);
				if(j>1) Modify(1,1,j-1,2);
				cntb--,cnts++;
			}else{
				if(j<n) Modify(1,j+1,n,0);
				if(j>1) Modify(1,1,j-1,inv);
				cnts--,cntt++;
			}
		}
		SubAs(ans,Mul(Mul(val[i]-val[i+1],tr[1].dat),QPow(2,cntb+cntt)));
	}
	Build(1,1,n);
	cntb=n,cnts=0,cntt=0;
	for(int i=1;i+1<val.size();i++){
		for(auto t:op[i]){
			int j=t[0];
			if(!t[1]){
				Set(1,j,j);
				if(j<n) Modify(1,j+1,n,2);
				cntb--,cnts++;
			}else{
				if(j>1) Modify(1,1,j-1,0);
				if(j<n) Modify(1,j+1,n,inv);
				cnts--,cntt++;
			}
		}
		AddAs(ans,Mul(Mul(val[i]-val[i+1],tr[1].dat),QPow(2,cntb+cntt)));
	}
	cntb=n,cnts=0,cntt=0;
	for(int i=1;i+1<val.size();i++){
		for(auto t:op[i]){
			if(!t[1]) cntb--,cnts++;
			else cnts--,cntt++;
		}
		if(!cntt){
			if(cnts) SubAs(ans,Mul(val[i]-val[i+1],Mul(cnts,QPow(2,cntb+cntt+cnts-1))));
		}else{
			SubAs(ans,Mul(val[i]-val[i+1],Mul(cntt,QPow(2,cntb+cntt+cnts))));
			if(cnts) SubAs(ans,Mul(val[i]-val[i+1],Mul(cnts,QPow(2,cntb+cntt+cnts-1))));
		}
	}

	cout<<ans<<endl;

	return 0;
}
```

