没能想到 Dilworth 定理，感性思考了一个做法，讲的不好的地方还请多多包含。

把所有箱子先按照存放容量 $c_i$ 排序，那么箱子 $i$ 可以放入的箱子 $j$ 就是一个后缀，令这个后缀为 $[d_i,n]$。

从后向前考虑，问题转化为：

- 有若干个物品，第 $i$ 个物品在 $d_i$ 之前没买就消失。
- 每天只能购买一个物品。
- 问最少要抛弃多少个物品。

这是一个经典的贪心问题，解决方式是优先购买临期商品。

不妨换个思路，先存着购买额度，等到了某个商品的 ddl 在时间穿梭回去买它，这和上面的贪心方式是等价的。

于是考虑维护 $c$ 上每个时刻的购买额度 $t_i$，共有两种事件：

- $i$ 时刻增加 $1$ 的额度：由于要存额度，并且额度不会过期。$\forall i\in[1,i],~t_i\leftarrow t_i+1$。

- $i$ 时刻某个物品到达 ddl：

  - 该物品买到了：额度用掉一个，并且永久有效。$\forall i\in[1,i],~t_i\leftarrow t_i-1$。
  - 该物品未买到：此时额度 $\leq 0$，仍强制消耗一个额度，并定义整个过程抛弃的物品数为 $\max(-\min\limits_{i=1}^{n} t_i,0)$。因为下次发生抛弃事件必然先消耗了后面增加的所有额度，故可以保证正确性。$\forall i\in[1,i],~t_i\leftarrow t_i-1$。

  可以合并为 $\forall i\in[1,i],~t_i\leftarrow t_i-1$。

于是需要维护的操作就是前缀 $\pm 1$，查全局最小值。存放 $[1,i]$ 的箱子所需的成本则可以通过按下标从小到大加入实现，时间复杂度 $O(n\log n)$。

可能和其他做法是等价的？

```cpp
#include<bits/stdc++.h>

using namespace std;

#define endl '\n'
const int N=2e5;
const int inf=1e9+7;

struct Node{
	int l,r,dat,tag;
}tr[N<<2];
#define l(x) tr[x].l
#define r(x) tr[x].r
#define dat(x) tr[x].dat
#define tag(x) tr[x].tag

inline void PushUp(int x){dat(x)=min(dat(x<<1),dat(x<<1|1));}
inline void Push(int x,int k){tag(x)+=k,dat(x)+=k;}
inline void PushDown(int x){
	if(!tag(x)) return ;
	Push(x<<1,tag(x));
	Push(x<<1|1,tag(x));
	tag(x)=0;
}
inline void Build(int x,int l,int r){
	l(x)=l,r(x)=r;
	if(l(x)==r(x)) return ;
	int mid=l(x)+r(x)>>1;
	Build(x<<1,l,mid);
	Build(x<<1|1,mid+1,r);
	PushUp(x);
}
inline void Modify(int x,int l,int r,int k){
	if(l<=l(x)&&r(x)<=r) return Push(x,k);
	int mid=l(x)+r(x)>>1;
	PushDown(x);
	if(l<=mid) Modify(x<<1,l,r,k);
	if(r>mid) Modify(x<<1|1,l,r,k);
	PushUp(x);
}

int a[N],b[N],n,tot;
vector<int> val;

signed main(){
	cin.tie(0),cout.tie(0);
	ios::sync_with_stdio(0);

	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i]>>b[i];

	val.push_back(0);
	val.push_back(inf);
	for(int i=1;i<=n;i++) val.push_back(b[i]);
	sort(val.begin(),val.end());
	val.erase(unique(val.begin(),val.end()),val.end());
	tot=val.size()-1;

	Build(1,1,tot);
	for(int i=1;i<=n;i++){
		int bp=lower_bound(val.begin(),val.end(),b[i])-val.begin();
		Modify(1,1,bp,1);
		int ap=lower_bound(val.begin(),val.end(),a[i])-val.begin();
		Modify(1,1,ap,-1);
		cout<<-dat(1)<<endl;
	}

	return 0;
}
```